{"version":3,"file":"relay-hooks.js","sources":["../../src/ReactRelayContext.ts","../../src/RelayHooksTypes.ts","../../src/Utils.ts","../../src/FetchResolver.ts","../../src/QueryFetcher.ts","../../src/useForceUpdate.ts","../../src/useRelayEnvironment.ts","../../src/useQuery.ts","../../src/loadQuery.ts","../../src/usePreloadedQuery.ts","../../node_modules/tslib/tslib.es6.js","../../src/getValueAtPath.ts","../../src/getConnectionState.ts","../../src/getRefetchMetadata.ts","../../src/getPaginationMetadata.ts","../../src/getPaginationVariables.ts","../../src/FragmentResolver.ts","../../src/useOssFragment.tsx","../../src/useFragment.tsx","../../src/useMutation.ts","../../src/useSubscription.ts","../../src/usePagination.ts","../../src/useRefetchable.ts","../../src/RelayEnvironmentProvider.tsx"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport * as React from 'react';\nimport { __internal } from 'relay-runtime';\n\nconst { createRelayContext } = __internal as any;\n\nexport const ReactRelayContext = createRelayContext(React);\n","import {\n    Disposable,\n    OperationType,\n    CacheConfig,\n    GraphQLTaggedNode,\n    IEnvironment,\n    MutationConfig as BaseMutationConfig,\n    MutationParameters,\n    FragmentSpecResolver,\n    VariablesOf,\n    FragmentReference,\n    RenderPolicy,\n    GraphQLSubscriptionConfig,\n} from 'relay-runtime';\n\nexport type MutationState<T extends MutationParameters> = {\n    loading: boolean;\n    data: T['response'] | null;\n    error?: Error | null;\n};\n\nexport type MutationNode<T extends MutationParameters> = BaseMutationConfig<T>['mutation'];\n\nexport type MutationConfig<T extends MutationParameters> = Partial<\n    Omit<BaseMutationConfig<T>, 'mutation' | 'onCompleted'>\n> & {\n    onCompleted?(response: T['response']): void;\n};\n\nexport type MutationConfigWithoutVariables<T extends MutationParameters> = Omit<\n    MutationConfig<T>,\n    'variables'\n>;\n\nexport type Mutate<T extends MutationParameters> = (\n    config?: Partial<MutationConfig<T>>,\n) => Promise<T['response']>;\n\nexport type MutateWithVariables<T extends MutationParameters> = (\n    config: Partial<MutationConfig<T>> & { variables: T['variables'] },\n) => Promise<T['response']>;\n\nexport const NETWORK_ONLY = 'network-only';\nexport const STORE_THEN_NETWORK = 'store-and-network';\nexport const STORE_OR_NETWORK = 'store-or-network';\nexport const STORE_ONLY = 'store-only';\n\nexport const PAGINATION_NAME = 'usePagination';\nexport const REFETCHABLE_NAME = 'useRefetchable';\nexport const FRAGMENT_NAME = 'useFragment';\n\nexport type FragmentNames = typeof PAGINATION_NAME | typeof REFETCHABLE_NAME | typeof FRAGMENT_NAME;\n\nexport type FetchPolicy =\n    | typeof STORE_ONLY\n    | typeof STORE_OR_NETWORK\n    | typeof STORE_THEN_NETWORK\n    | typeof NETWORK_ONLY;\n\nexport type ContainerResult = {\n    data: { [key: string]: any };\n    resolver: FragmentSpecResolver;\n};\n\nexport interface RenderProps<T extends OperationType> {\n    error: Error | null;\n    data: T['response'] | null | undefined;\n    retry: (_cacheConfigOverride?: CacheConfig, options?: Options) => void;\n    isLoading: boolean;\n}\n\nexport type QueryOptions = {\n    fetchPolicy?: FetchPolicy;\n    fetchKey?: string | number;\n    networkCacheConfig?: CacheConfig;\n    skip?: boolean;\n    onComplete?: (_e: Error | null) => void;\n    UNSTABLE_renderPolicy?: RenderPolicy;\n};\n\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (arg: any) => infer RT\n    ? RT\n    : never;\n\nexport type KeyType<TData = unknown> = Readonly<{\n    ' $data'?: TData;\n    ' $fragmentRefs': FragmentReference;\n}>;\nexport type ArrayKeyType = ReadonlyArray<{ readonly ' $data'?: ReadonlyArray<unknown> } | null>;\n\nexport type KeyTypeData<TKey extends KeyType<TData>, TData = unknown> = Required<TKey>[' $data'];\n\nexport type KeyReturnType<T extends KeyType> = (arg: T) => NonNullable<T[' $data']>;\nexport type ArrayKeyReturnType<T extends ArrayKeyType> = (\n    arg: T,\n) => NonNullable<NonNullable<T[0]>[' $data']>[0];\n\nexport type LoadMoreFn<TQuery extends OperationType = OperationType> = (\n    count: number,\n    options?: OptionsLoadMore<TQuery>,\n) => Disposable;\n\n// pagination\n\nexport const FORWARD = 'forward';\n\nexport type LoadQuery<\n    TOperationType extends OperationType = OperationType,\n    TEnvironment extends IEnvironment = IEnvironment\n> = {\n    next: (\n        environment: TEnvironment,\n        gqlQuery: GraphQLTaggedNode,\n        variables?: TOperationType['variables'],\n        options?: QueryOptions,\n    ) => Promise<void>;\n    subscribe: (callback: () => any) => () => void;\n    getValue: (environment?: TEnvironment) => RenderProps<TOperationType> | Promise<any>;\n    dispose: () => void;\n};\n\n// refetchable\n\nexport interface Options {\n    fetchPolicy?: FetchPolicy;\n    onComplete?: (arg: Error | null) => void;\n    UNSTABLE_renderPolicy?: RenderPolicy;\n}\n\nexport interface OptionsLoadMore<TQuery extends OperationType = OperationType> {\n    //fetchPolicy?: FetchPolicy;\n    onComplete?: (arg: Error | null) => void;\n    UNSTABLE_extraVariables?: VariablesOf<TQuery>;\n}\n\n// NOTE: RefetchFnDynamic returns a refetch function that:\n//  - Expects the /exact/ set of query variables if the provided key type is\n//    /nullable/.\n//  - Or, expects /a subset/ of the query variables if the provided key type is\n//    /non-null/.\nexport type RefetchFnDynamic<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TOptions = Options\n> = RefetchInexactDynamicResponse<TQuery, TOptions> & RefetchExactDynamicResponse<TQuery, TOptions>;\n\nexport type RefetchInexact<TQuery extends OperationType, TOptions> = (\n    data?: unknown,\n) => RefetchFnInexact<TQuery, TOptions>;\nexport type RefetchInexactDynamicResponse<TQuery extends OperationType, TOptions> = ReturnType<\n    RefetchInexact<TQuery, TOptions>\n>;\n\nexport type RefetchExact<TQuery extends OperationType, TOptions> = (\n    data?: unknown | null,\n) => RefetchFnExact<TQuery, TOptions>;\nexport type RefetchExactDynamicResponse<TQuery extends OperationType, TOptions> = ReturnType<\n    RefetchExact<TQuery, TOptions>\n>;\n\nexport type RefetchFnBase<TVars, TOptions> = (vars: TVars, options?: TOptions) => Disposable;\n\nexport type RefetchFnExact<TQuery extends OperationType, TOptions = Options> = RefetchFnBase<\n    VariablesOf<TQuery>,\n    TOptions\n>;\nexport type RefetchFnInexact<TQuery extends OperationType, TOptions = Options> = RefetchFnBase<\n    Partial<VariablesOf<TQuery>>,\n    TOptions\n>;\n\nexport interface ReturnTypeRefetchNode<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> extends ReturnTypeRefetchSuspenseNode<TQuery, TKey, TFragmentData> {\n    isLoading: boolean;\n    error: Error | null;\n}\n\nexport type ReturnTypeRefetchSuspenseNode<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> = { data: TFragmentData; refetch: RefetchFnDynamic<TQuery, TKey> };\n\n// pagination\n\nexport interface ReturnTypePagination<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> extends ReturnTypePaginationSuspense<TQuery, TKey, TFragmentData> {\n    isLoading: boolean;\n    error: Error | null;\n}\n\nexport interface ReturnTypePaginationSuspense<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> {\n    data: TFragmentData;\n    loadNext: LoadMoreFn<TQuery>;\n    loadPrevious: LoadMoreFn<TQuery>;\n    hasNext: boolean;\n    hasPrevious: boolean;\n    isLoadingNext: boolean;\n    isLoadingPrevious: boolean;\n    errorNext: Error | null;\n    errorPrevious: Error | null;\n    refetch: RefetchFnDynamic<TQuery, TKey>;\n}\n\nexport type SubscriptionConfig = {\n    skip?: boolean;\n};\n\nexport type SkipSubscriptionConfig = {\n    skip: true;\n};\n\nexport interface SkipGraphQLSubscriptionConfig<TSubscription extends OperationType>\n    extends Omit<GraphQLSubscriptionConfig<TSubscription>, 'variables' | 'subscription'> {\n    subscription?: GraphQLSubscriptionConfig<TSubscription>['subscription'];\n    variables?: TSubscription['variables'];\n}\n","import {\n    Variables,\n    ConnectionMetadata,\n    createOperationDescriptor,\n    getRequest,\n    GraphQLTaggedNode,\n    OperationDescriptor,\n    CacheConfig,\n} from 'relay-runtime';\nimport { STORE_OR_NETWORK, STORE_THEN_NETWORK, NETWORK_ONLY, FetchPolicy } from './RelayHooksTypes';\n\nexport type ReactConnectionMetadata = ConnectionMetadata & { fragmentName: string };\n\nexport const isNetworkPolicy = (policy: FetchPolicy, full: boolean): boolean => {\n    return (\n        policy === NETWORK_ONLY ||\n        policy === STORE_THEN_NETWORK ||\n        (policy === STORE_OR_NETWORK && !full)\n    );\n};\n\nexport const isStorePolicy = (policy: FetchPolicy): boolean => {\n    return policy !== NETWORK_ONLY;\n};\n\nexport const forceCache = { force: true };\n\n// Fetcher\nexport function createOperation(\n    gqlQuery: GraphQLTaggedNode,\n    variables: Variables,\n    cacheConfig?: CacheConfig | null,\n): OperationDescriptor {\n    return createOperationDescriptor(getRequest(gqlQuery), variables, cacheConfig);\n}\n","import {\n    __internal,\n    Disposable,\n    FetchPolicy,\n    Subscription,\n    OperationDescriptor,\n    IEnvironment,\n    Snapshot,\n    RenderPolicy,\n} from 'relay-runtime';\nimport { isNetworkPolicy, isStorePolicy } from './Utils';\nconst { fetchQuery } = __internal;\nconst DATA_RETENTION_TIMEOUT = 30 * 1000;\n\nexport type Fetcher = {\n    fetch: (\n        environment: IEnvironment,\n        operation: OperationDescriptor,\n        fetchPolicy: FetchPolicy | null | undefined,\n        onComplete: (_e: Error | null) => void,\n        onNext: (\n            operation: OperationDescriptor,\n            snapshot: Snapshot,\n            fromStore?: boolean,\n            onlyStore?: boolean,\n        ) => void,\n        renderPolicy?: RenderPolicy,\n    ) => Disposable;\n    getData: () => {\n        isLoading: boolean;\n        error?: Error | null;\n    };\n    dispose: () => void;\n    checkAndSuspense: (suspense: boolean, useLazy?: boolean) => Promise<any> | Error | null;\n};\n\nexport function fetchResolver({\n    setLoading,\n    doRetain = true,\n    disposeTemporary,\n}: {\n    doRetain?: boolean;\n    setLoading?: (loading: boolean) => void;\n    disposeTemporary?: () => void;\n}): Fetcher {\n    let _refetchSubscription: Subscription | null = null;\n    let disposable: Disposable | null = null;\n    let releaseQueryTimeout;\n    let isLoading = false;\n    let query;\n    let promise: Promise<any>;\n    let error: Error | null = null;\n    let env;\n\n    const updateLoading = (loading: boolean): void => {\n        isLoading = loading;\n        setLoading && setLoading(isLoading);\n    };\n    const lookupInStore = (\n        environment: IEnvironment,\n        operation,\n        fetchPolicy,\n        renderPolicy: RenderPolicy,\n    ): { snapshot: Snapshot | null; full: boolean } => {\n        if (isStorePolicy(fetchPolicy)) {\n            const check = environment.check(operation);\n            const queryStatus = check.status;\n            const hasFullQuery = queryStatus === 'available';\n            const canPartialRender =\n                hasFullQuery || (renderPolicy === 'partial' && queryStatus !== 'stale');\n            if (canPartialRender) {\n                return { snapshot: environment.lookup(operation.fragment), full: hasFullQuery };\n            }\n        }\n        return { snapshot: null, full: false };\n    };\n\n    const dispose = (): void => {\n        clearTemporaryRetain();\n        disposable && disposable.dispose();\n        disposeRequest();\n        disposable = null;\n        env = null;\n        query = null;\n    };\n\n    const clearTemporaryRetain = (): void => {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n    };\n\n    const temporaryRetain = (): void => {\n        const localReleaseTemporaryRetain = (): void => {\n            clearTemporaryRetain();\n            dispose();\n            disposeTemporary && disposeTemporary();\n        };\n        releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT);\n    };\n\n    const disposeRequest = (): void => {\n        _refetchSubscription && _refetchSubscription.unsubscribe();\n        error = null;\n    };\n\n    const fetch = (\n        environment: IEnvironment,\n        operation: OperationDescriptor,\n        fetchPolicy: FetchPolicy = 'network-only',\n        onComplete = (_e: Error | null): void => undefined,\n        onNext: (\n            operation: OperationDescriptor,\n            snapshot: Snapshot,\n            fromStore?: boolean,\n            onlyStore?: boolean,\n        ) => void,\n        renderPolicy?: RenderPolicy,\n    ): Disposable => {\n        if (env != environment || query.request.identifier !== operation.request.identifier) {\n            dispose();\n            if (doRetain) {\n                disposable = environment.retain(operation);\n            }\n        }\n        env = environment;\n        query = operation;\n\n        disposeRequest();\n        const { snapshot, full } = lookupInStore(environment, operation, fetchPolicy, renderPolicy);\n        const isNetwork = isNetworkPolicy(fetchPolicy, full);\n        if (snapshot != null) {\n            const onlyStore = !isNetwork;\n            onNext(operation, snapshot, true, onlyStore);\n            if (onlyStore) {\n                onComplete(null);\n            }\n        }\n        // Cancel any previously running refetch.\n        _refetchSubscription && _refetchSubscription.unsubscribe();\n        if (isNetwork) {\n            let resolveNetworkPromise = (): void => {};\n\n            // Declare refetchSubscription before assigning it in .start(), since\n            // synchronous completion may call callbacks .subscribe() returns.\n            let refetchSubscription: Subscription;\n            const cleanup = (): void => {\n                if (_refetchSubscription === refetchSubscription) {\n                    _refetchSubscription = null;\n                }\n                isLoading = false;\n                promise = null;\n            };\n\n            fetchQuery(environment, operation).subscribe({\n                unsubscribe: (): void => {\n                    cleanup();\n                },\n                complete: (): void => {\n                    resolveNetworkPromise();\n                    updateLoading(false);\n                    cleanup();\n                    onComplete(null);\n                },\n                error: (e: Error): void => {\n                    error = e;\n                    resolveNetworkPromise();\n                    updateLoading(false);\n                    cleanup();\n                    onComplete(e);\n                },\n                next: () => {\n                    const store = environment.lookup(operation.fragment);\n                    promise = null;\n                    operation.request.cacheConfig?.poll && updateLoading(false);\n                    resolveNetworkPromise();\n                    onNext(operation, store);\n                },\n                start: (subscription) => {\n                    refetchSubscription = subscription;\n                    _refetchSubscription = refetchSubscription;\n                    updateLoading(true);\n                },\n            });\n            if (!snapshot) {\n                promise = new Promise((resolve: any) => {\n                    resolveNetworkPromise = resolve;\n                });\n            }\n            return {\n                dispose: (): void => {\n                    refetchSubscription && refetchSubscription.unsubscribe();\n                },\n            };\n        }\n        return {\n            dispose: (): void => {},\n        };\n    };\n\n    const checkAndSuspense = (suspense, useLazy): Promise<any> | Error | null => {\n        clearTemporaryRetain();\n        const toThrow = promise || error;\n        if (suspense && toThrow) {\n            if (promise && useLazy) {\n                temporaryRetain();\n            }\n            throw toThrow;\n        }\n        return toThrow;\n    };\n\n    const getData = (): {\n        isLoading: boolean;\n        error?: Error | null;\n    } => {\n        return {\n            isLoading,\n            error,\n        };\n    };\n\n    return {\n        fetch,\n        getData,\n        dispose,\n        checkAndSuspense,\n    };\n}\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport {\n    Disposable,\n    CacheConfig,\n    IEnvironment,\n    Snapshot,\n    OperationType,\n    OperationDescriptor,\n    GraphQLTaggedNode,\n    Variables,\n} from 'relay-runtime';\nimport { Fetcher, fetchResolver } from './FetchResolver';\nimport { FetchPolicy, RenderProps, QueryOptions, Options } from './RelayHooksTypes';\nimport { createOperation } from './Utils';\n\nconst defaultPolicy = 'network-only';\n\nconst cache: Map<string, QueryFetcher<any>> = new Map();\n\nexport function getOrCreateQueryFetcher<TOperationType extends OperationType>(\n    useLazy: boolean,\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'],\n    networkCacheConfig: CacheConfig,\n): QueryFetcher<TOperationType> {\n    const query = createOperation(gqlQuery, variables, networkCacheConfig);\n    const toGet = useLazy && cache.has(query.request.identifier);\n    const queryFetcher = toGet ? cache.get(query.request.identifier) : new QueryFetcher();\n    queryFetcher.setQuery(gqlQuery, variables, networkCacheConfig, query);\n    return queryFetcher;\n}\n\nconst emptyforceUpdate = (): void => undefined;\n\nexport class QueryFetcher<TOperationType extends OperationType = OperationType> {\n    environment: IEnvironment;\n    query: OperationDescriptor;\n    fetcher: Fetcher;\n    rootSubscription: Disposable;\n    snapshot: Snapshot;\n    fetchPolicy: FetchPolicy;\n    fetchKey: string | number;\n    variables: Variables;\n    cacheConfig: Variables;\n    gqlQuery: GraphQLTaggedNode;\n    options: QueryOptions;\n    forceUpdate = emptyforceUpdate;\n    result: RenderProps<TOperationType> = null;\n    skip?: boolean;\n\n    constructor() {\n        this.result = {\n            retry: this.retry,\n            error: null,\n            data: null,\n            isLoading: false,\n        };\n        this.fetcher = fetchResolver({\n            disposeTemporary: () => {\n                this.dispose();\n                this.query && cache.delete(this.query.request.identifier);\n            },\n        });\n    }\n\n    setQuery(\n        gqlQuery: GraphQLTaggedNode,\n        variables: TOperationType['variables'],\n        networkCacheConfig: CacheConfig,\n        query: OperationDescriptor,\n    ): void {\n        this.gqlQuery = gqlQuery;\n        this.variables = variables;\n        this.query = query;\n        this.cacheConfig = networkCacheConfig;\n    }\n\n    getForceUpdate(): () => void {\n        return this.forceUpdate;\n    }\n\n    setForceUpdate(forceUpdate): void {\n        this.forceUpdate = forceUpdate;\n    }\n\n    dispose(): void {\n        this.fetcher.dispose();\n        this.disposeSnapshot();\n    }\n\n    disposeSnapshot(): void {\n        this.snapshot = null;\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n            this.rootSubscription = null;\n        }\n    }\n\n    retry = (cacheConfigOverride?: CacheConfig | null, options: Options = {}): void => {\n        const { fetchPolicy = 'network-only' } = options;\n        /* eslint-disable indent */\n        const query = cacheConfigOverride\n            ? createOperation(\n                  this.query.request.node,\n                  this.query.request.variables,\n                  cacheConfigOverride,\n              )\n            : this.query;\n        this.fetch(query, fetchPolicy, options);\n        this.resolveResult();\n        this.forceUpdate();\n    };\n\n    fetch(\n        query: OperationDescriptor,\n        fetchPolicy: FetchPolicy,\n        options: Options,\n        skip?: boolean,\n    ): void {\n        this.disposeSnapshot();\n        if (skip) {\n            this.fetcher.dispose();\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        const { onComplete } = options;\n        let fetchHasReturned = false;\n        const onNext = (_o: OperationDescriptor, snapshot: Snapshot): void => {\n            if (!this.snapshot) {\n                this.snapshot = snapshot;\n                this.subscribe(snapshot);\n                this.resolveResult();\n                if (fetchHasReturned) {\n                    this.forceUpdate();\n                }\n            }\n        };\n        const complete = (error: Error | null): void => {\n            this.resolveResult();\n            if (fetchHasReturned) {\n                this.forceUpdate();\n            }\n            onComplete && onComplete(error);\n        };\n        this.fetcher.fetch(this.environment, query, fetchPolicy, complete, onNext);\n        fetchHasReturned = true;\n    }\n\n    getQuery(gqlQuery, variables, networkCacheConfig): OperationDescriptor | null {\n        if (\n            gqlQuery != this.gqlQuery ||\n            networkCacheConfig != this.cacheConfig ||\n            variables != this.variables ||\n            !areEqual(variables, this.variables)\n        ) {\n            this.variables = variables;\n            this.gqlQuery = gqlQuery;\n            this.cacheConfig = networkCacheConfig;\n            return createOperation(gqlQuery, variables, networkCacheConfig);\n        }\n        return this.query;\n    }\n\n    resolveEnvironment(environment: IEnvironment): void {\n        this.resolve(environment, this.gqlQuery, this.variables, this.options);\n    }\n\n    resolve(\n        environment: IEnvironment,\n        gqlQuery: GraphQLTaggedNode,\n        variables: Variables,\n        options: QueryOptions,\n    ): void {\n        const query = this.getQuery(gqlQuery, variables, options.networkCacheConfig);\n        const { fetchPolicy = defaultPolicy, fetchKey, skip } = options;\n        this.options = options;\n        const diffQuery = !this.query || query.request.identifier !== this.query.request.identifier;\n        if (\n            diffQuery ||\n            environment !== this.environment ||\n            fetchPolicy !== this.fetchPolicy ||\n            fetchKey !== this.fetchKey ||\n            skip !== this.skip\n        ) {\n            this.environment = environment;\n            this.query = query;\n            this.skip = skip;\n            this.fetchPolicy = fetchPolicy;\n            this.fetchKey = fetchKey;\n            this.fetch(query, fetchPolicy, options, skip);\n            this.resolveResult();\n        }\n    }\n\n    checkAndSuspense(suspense?: boolean, useLazy?: boolean): Promise<any> | Error | null {\n        if (useLazy) {\n            this.setForceUpdate(emptyforceUpdate);\n            cache.set(this.query.request.identifier, this);\n        }\n        const result = this.fetcher.checkAndSuspense(suspense, useLazy);\n        if (useLazy) {\n            cache.delete(this.query.request.identifier);\n        }\n        return result;\n    }\n\n    getData(): RenderProps<TOperationType> {\n        return this.result;\n    }\n\n    resolveResult(): void {\n        const { error, isLoading } = this.fetcher.getData();\n        this.result = {\n            retry: this.retry,\n            error,\n            data: this.snapshot ? this.snapshot.data : null,\n            isLoading,\n        };\n    }\n\n    subscribe(snapshot): void {\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n        }\n        this.rootSubscription = this.environment.subscribe(snapshot, (snapshot) => {\n            // Read from this._fetchOptions in case onDataChange() was lazily added.\n            this.snapshot = snapshot;\n            //this.error = null;\n\n            this.resolveResult();\n            this.forceUpdate();\n        });\n    }\n}\n","import { Reducer, useReducer } from 'react';\n\nexport function useForceUpdate(): () => void {\n    const [, forceUpdate] = useReducer<Reducer<number, void>>((x) => x + 1, 0);\n    return forceUpdate as () => void;\n}\n","import * as React from 'react';\nimport { IEnvironment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext';\n\nexport function useRelayEnvironment<\n    TEnvironment extends IEnvironment = IEnvironment\n>(): TEnvironment {\n    const { environment } = React.useContext(ReactRelayContext);\n    return environment;\n}\n","import { useRef, useEffect } from 'react';\nimport { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport { getOrCreateQueryFetcher, QueryFetcher } from './QueryFetcher';\nimport { RenderProps, QueryOptions } from './RelayHooksTypes';\nimport { useForceUpdate } from './useForceUpdate';\nimport { useRelayEnvironment } from './useRelayEnvironment';\nimport { forceCache } from './Utils';\n\ntype Reference<TOperationType extends OperationType = OperationType> = {\n    queryFetcher: QueryFetcher<TOperationType>;\n};\n\nconst useInternalQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'],\n    options: QueryOptions,\n    suspense: boolean,\n): RenderProps<TOperationType> => {\n    const environment = useRelayEnvironment();\n    const forceUpdate = useForceUpdate();\n    const ref = useRef<Reference<TOperationType>>();\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            queryFetcher: getOrCreateQueryFetcher(\n                suspense,\n                gqlQuery,\n                variables,\n                options.networkCacheConfig,\n            ),\n        };\n    }\n\n    useEffect(() => {\n        return (): void => ref.current.queryFetcher.dispose();\n    }, []);\n\n    const { queryFetcher } = ref.current;\n    queryFetcher.resolve(environment, gqlQuery, variables, options);\n    queryFetcher.checkAndSuspense(suspense, suspense);\n    queryFetcher.setForceUpdate(forceUpdate);\n    return queryFetcher.getData();\n};\n\nexport const useQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    return useInternalQuery(gqlQuery, variables, options, false);\n};\n\nexport const useLazyLoadQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    options.networkCacheConfig = options.networkCacheConfig ?? forceCache;\n    return useInternalQuery(gqlQuery, variables, options, true);\n};\n","import { GraphQLTaggedNode, OperationType, IEnvironment } from 'relay-runtime';\nimport { QueryFetcher } from './QueryFetcher';\nimport { RenderProps, QueryOptions, LoadQuery } from './RelayHooksTypes';\nimport { forceCache } from './Utils';\n\nconst emptyFunction = (): void => undefined;\n\nexport const internalLoadQuery = <TOperationType extends OperationType = OperationType>(\n    promise = false,\n): LoadQuery<TOperationType> => {\n    let queryFetcher = new QueryFetcher<TOperationType>();\n\n    const dispose = (): void => {\n        queryFetcher.dispose();\n        queryFetcher.setForceUpdate(emptyFunction);\n        queryFetcher = new QueryFetcher<TOperationType>();\n    };\n\n    const next = (\n        environment,\n        gqlQuery: GraphQLTaggedNode,\n        variables: TOperationType['variables'] = {},\n        options: QueryOptions = {},\n    ): Promise<void> => {\n        options.networkCacheConfig = options.networkCacheConfig ?? forceCache;\n        queryFetcher.resolve(environment, gqlQuery, variables, options);\n        const toThrow = queryFetcher.checkAndSuspense();\n        return toThrow\n            ? toThrow instanceof Error\n                ? Promise.reject(toThrow)\n                : toThrow\n            : Promise.resolve();\n    };\n\n    const getValue = (\n        environment?: IEnvironment,\n    ): RenderProps<TOperationType> | null | Promise<any> => {\n        queryFetcher.resolveEnvironment(environment);\n        queryFetcher.checkAndSuspense(promise);\n        return queryFetcher.getData();\n    };\n\n    const subscribe = (callback: () => any): (() => void) => {\n        queryFetcher.setForceUpdate(callback);\n        return (): void => {\n            if (queryFetcher.getForceUpdate() === callback) {\n                queryFetcher.setForceUpdate(emptyFunction);\n            }\n        };\n    };\n    return {\n        next,\n        subscribe,\n        getValue,\n        dispose,\n    };\n};\n\nexport const loadLazyQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(true);\n};\n\nexport const loadQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(false);\n};\n","import { useEffect } from 'react';\nimport { OperationType } from 'relay-runtime';\nimport { RenderProps, LoadQuery } from './RelayHooksTypes';\nimport { useForceUpdate } from './useForceUpdate';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport const usePreloadedQuery = <TOperationType extends OperationType = OperationType>(\n    loadQuery: LoadQuery,\n): RenderProps<TOperationType> => {\n    const forceUpdate = useForceUpdate();\n    const environment = useRelayEnvironment();\n\n    useEffect(() => {\n        return loadQuery.subscribe(forceUpdate);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [loadQuery]);\n\n    return loadQuery.getValue(environment) as RenderProps<TOperationType>;\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import * as invariant from 'fbjs/lib/invariant';\n\nexport function getValueAtPath(data: any, path: ReadonlyArray<string | number>): any {\n    let result = data;\n    for (const key of path) {\n        if (result == null) {\n            return null;\n        }\n        if (typeof key === 'number') {\n            invariant(\n                Array.isArray(result),\n                'Relay: Expected an array when extracting value at path. ' +\n                    \"If you're seeing this, this is likely a bug in Relay.\",\n            );\n            result = result[key];\n        } else {\n            invariant(\n                typeof result === 'object' && !Array.isArray(result),\n                'Relay: Expected an object when extracting value at path. ' +\n                    \"If you're seeing this, this is likely a bug in Relay.\",\n            );\n            result = result[key];\n        }\n    }\n    return result;\n}\n","import * as invariant from 'fbjs/lib/invariant';\nimport { ConnectionInterface, ReaderFragment } from 'relay-runtime';\nimport { getValueAtPath } from './getValueAtPath';\n\nexport function getStateFromConnection(\n    direction: string,\n    fragmentNode: ReaderFragment,\n    connection: any | null,\n): {\n    cursor: string | null;\n    hasMore: boolean;\n} {\n    if (connection == null) {\n        return { cursor: null, hasMore: false };\n    }\n    const {\n        EDGES,\n        PAGE_INFO,\n        HAS_NEXT_PAGE,\n        HAS_PREV_PAGE,\n        END_CURSOR,\n        START_CURSOR,\n    } = ConnectionInterface.get();\n\n    invariant(\n        typeof connection === 'object',\n        'Relay: Expected connection in fragment `%s` to have been `null`, or ' +\n            'a plain object with %s and %s properties. Instead got `%s`.',\n        fragmentNode.name,\n        EDGES,\n        PAGE_INFO,\n        connection,\n    );\n\n    const edges = connection[EDGES];\n    const pageInfo = connection[PAGE_INFO];\n    if (edges == null || pageInfo == null) {\n        return { cursor: null, hasMore: false };\n    }\n\n    invariant(\n        Array.isArray(edges),\n        'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' +\n            'Instead got `%s`.',\n        fragmentNode.name,\n        EDGES,\n        edges,\n    );\n    invariant(\n        typeof pageInfo === 'object',\n        'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.',\n        fragmentNode.name,\n        PAGE_INFO,\n        pageInfo,\n    );\n\n    const cursor =\n        direction === 'forward' ? pageInfo[END_CURSOR] ?? null : pageInfo[START_CURSOR] ?? null;\n    invariant(\n        cursor === null || typeof cursor === 'string',\n        'Relay: Expected page info for connection in fragment `%s` to have a ' +\n            'valid `%s`. Instead got `%s`.',\n        fragmentNode.name,\n        START_CURSOR,\n        cursor,\n    );\n\n    let hasMore;\n    if (direction === 'forward') {\n        hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;\n    } else {\n        hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;\n    }\n\n    return { cursor, hasMore };\n}\n\nexport function getConnectionState(\n    direction: string,\n    fragmentNode: ReaderFragment,\n    fragmentData: any,\n    connectionPathInFragmentData: ReadonlyArray<string | number>,\n): {\n    cursor: string | null;\n    hasMore: boolean;\n} {\n    const connection = getValueAtPath(fragmentData, connectionPathInFragmentData);\n    return getStateFromConnection(direction, fragmentNode, connection);\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * @flow strict-local\n * @format\n */\n\n// flowlint ambiguous-object-type:error\n\n'use strict';\n\nimport * as invariant from 'fbjs/lib/invariant';\n\nimport { ConcreteRequest, ReaderFragment, ReaderRefetchMetadata } from 'relay-runtime';\n\nexport function getRefetchMetadata(\n    fragmentNode: ReaderFragment,\n    componentDisplayName: string,\n): {\n    fragmentRefPathInResponse: ReadonlyArray<string | number>;\n    identifierField: string | null;\n    refetchableRequest: ConcreteRequest;\n    refetchMetadata: ReaderRefetchMetadata;\n} {\n    invariant(\n        fragmentNode.metadata?.plural !== true,\n        'Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using ' +\n            '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' +\n            'in order to use it with `%s`.',\n        fragmentNode.name,\n        componentDisplayName,\n        fragmentNode.name,\n        componentDisplayName,\n    );\n\n    const refetchMetadata = fragmentNode.metadata?.refetch;\n    invariant(\n        refetchMetadata != null,\n        'Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. ' +\n            'Did you forget to add a @refetchable directive to the fragment?',\n        componentDisplayName,\n        fragmentNode.name,\n    );\n\n    // handle both commonjs and es modules\n    const refetchableRequest: ConcreteRequest = (refetchMetadata as any).operation.default\n        ? (refetchMetadata as any).operation.default\n        : refetchMetadata.operation;\n    const fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;\n    invariant(\n        typeof refetchableRequest !== 'string',\n        'Relay: getRefetchMetadata(): Expected refetch query to be an ' +\n            \"operation and not a string when using `%s`. If you're seeing this, \" +\n            'this is likely a bug in Relay.',\n        componentDisplayName,\n    );\n    const identifierField = refetchMetadata.identifierField;\n    invariant(\n        identifierField == null || typeof identifierField === 'string',\n        'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.',\n    );\n    return {\n        fragmentRefPathInResponse,\n        identifierField,\n        refetchableRequest,\n        refetchMetadata,\n    };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * @flow strict-local\n * @format\n */\n\n// flowlint ambiguous-object-type:error\n\n'use strict';\n\nimport * as invariant from 'fbjs/lib/invariant';\n\nimport { ConcreteRequest, ReaderFragment, ReaderPaginationMetadata } from 'relay-runtime';\nimport { getRefetchMetadata } from './getRefetchMetadata';\n\nexport function getPaginationMetadata(\n    fragmentNode: ReaderFragment,\n    componentDisplayName: string,\n): {\n    connectionPathInFragmentData: ReadonlyArray<string | number>;\n    identifierField: string | null;\n    paginationRequest: ConcreteRequest;\n    paginationMetadata: ReaderPaginationMetadata;\n    stream: boolean;\n} {\n    const { refetchableRequest: paginationRequest, refetchMetadata } = getRefetchMetadata(\n        fragmentNode,\n        componentDisplayName,\n    );\n\n    const paginationMetadata = refetchMetadata.connection;\n    invariant(\n        paginationMetadata != null,\n        'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' +\n            'connection when using `%s`. Did you forget to add a @connection ' +\n            'directive to the connection field in the fragment?',\n        componentDisplayName,\n        fragmentNode.name,\n    );\n    const connectionPathInFragmentData = paginationMetadata.path;\n\n    const connectionMetadata = (fragmentNode.metadata?.connection ?? [])[0];\n    invariant(\n        connectionMetadata != null,\n        'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' +\n            'connection when using `%s`. Did you forget to add a @connection ' +\n            'directive to the connection field in the fragment?',\n        componentDisplayName,\n        fragmentNode.name,\n    );\n    const identifierField = refetchMetadata.identifierField;\n    invariant(\n        identifierField == null || typeof identifierField === 'string',\n        'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.',\n    );\n    return {\n        connectionPathInFragmentData,\n        identifierField,\n        paginationRequest,\n        paginationMetadata,\n        stream: connectionMetadata.stream === true,\n    };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * @flow strict-local\n * @format\n */\n\n// flowlint ambiguous-object-type:error\n\n'use strict';\n\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as warning from 'fbjs/lib/warning';\n\nimport { ReaderPaginationMetadata, Variables } from 'relay-runtime';\n\nexport function getPaginationVariables(\n    direction: 'forward' | 'backward',\n    count: number,\n    cursor: string | null,\n    baseVariables: Variables,\n    extraVariables: Variables,\n    paginationMetadata: ReaderPaginationMetadata,\n): { [key: string]: any } {\n    const { backward: backwardMetadata, forward: forwardMetadata } = paginationMetadata;\n\n    if (direction === 'backward') {\n        invariant(\n            backwardMetadata != null &&\n                backwardMetadata.count != null &&\n                backwardMetadata.cursor != null,\n            'Relay: Expected backward pagination metadata to be available. ' +\n                \"If you're seeing this, this is likely a bug in Relay.\",\n        );\n        warning(\n            !extraVariables.hasOwnProperty(backwardMetadata.cursor),\n            'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n                'contain cursor variable `%s`. This variable is automatically ' +\n                'determined by Relay.',\n            backwardMetadata.cursor,\n        );\n        warning(\n            !extraVariables.hasOwnProperty(backwardMetadata.count),\n            'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n                'contain count variable `%s`. This variable is automatically ' +\n                'determined by Relay.',\n            backwardMetadata.count,\n        );\n        const paginationVariables = {\n            ...baseVariables,\n            ...extraVariables,\n            [backwardMetadata.cursor]: cursor,\n            [backwardMetadata.count]: count,\n        };\n        if (forwardMetadata && forwardMetadata.cursor) {\n            paginationVariables[forwardMetadata.cursor] = null;\n        }\n        if (forwardMetadata && forwardMetadata.count) {\n            paginationVariables[forwardMetadata.count] = null;\n        }\n        return paginationVariables;\n    }\n\n    invariant(\n        forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null,\n        'Relay: Expected forward pagination metadata to be available. ' +\n            \"If you're seeing this, this is likely a bug in Relay.\",\n    );\n    warning(\n        !extraVariables.hasOwnProperty(forwardMetadata.cursor),\n        'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n            'contain cursor variable `%s`. This variable is automatically ' +\n            'determined by Relay.',\n        forwardMetadata.cursor,\n    );\n    warning(\n        !extraVariables.hasOwnProperty(forwardMetadata.count),\n        'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n            'contain count variable `%s`. This variable is automatically ' +\n            'determined by Relay.',\n        forwardMetadata.count,\n    );\n    const paginationVariables = {\n        ...baseVariables,\n        ...extraVariables,\n        [forwardMetadata.cursor]: cursor,\n        [forwardMetadata.count]: count,\n    };\n    if (backwardMetadata && backwardMetadata.cursor) {\n        paginationVariables[backwardMetadata.cursor] = null;\n    }\n    if (backwardMetadata && backwardMetadata.count) {\n        paginationVariables[backwardMetadata.count] = null;\n    }\n    return paginationVariables;\n}\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as warning from 'fbjs/lib/warning';\nimport {\n    __internal,\n    getSelector,\n    IEnvironment,\n    Disposable,\n    Snapshot,\n    Variables,\n    getVariablesFromFragment,\n    OperationDescriptor,\n    getFragmentIdentifier,\n    PluralReaderSelector,\n    ReaderSelector,\n    SingularReaderSelector,\n    ReaderFragment,\n    getDataIDsFromFragment,\n    RequestDescriptor,\n} from 'relay-runtime';\nimport { Fetcher, fetchResolver } from './FetchResolver';\nimport { getConnectionState, getStateFromConnection } from './getConnectionState';\nimport { getPaginationMetadata } from './getPaginationMetadata';\nimport { getPaginationVariables } from './getPaginationVariables';\nimport { getRefetchMetadata } from './getRefetchMetadata';\nimport { getValueAtPath } from './getValueAtPath';\nimport {\n    FragmentNames,\n    Options,\n    OptionsLoadMore,\n    PAGINATION_NAME,\n    REFETCHABLE_NAME,\n} from './RelayHooksTypes';\nimport { createOperation, forceCache } from './Utils';\nconst { getPromiseForActiveRequest } = __internal;\n\ntype SingularOrPluralSnapshot = Snapshot | Array<Snapshot>;\n\nfunction lookupFragment(environment, selector): SingularOrPluralSnapshot {\n    return selector.kind === 'PluralReaderSelector'\n        ? selector.selectors.map((s) => environment.lookup(s))\n        : environment.lookup(selector);\n}\n\nfunction getFragmentResult(snapshot: SingularOrPluralSnapshot): any {\n    const missData = isMissingData(snapshot);\n    if (Array.isArray(snapshot)) {\n        return { snapshot, data: snapshot.map((s) => s.data), isMissingData: missData };\n    }\n    return { snapshot, data: snapshot.data, isMissingData: missData };\n}\n\ntype FragmentResult = {\n    snapshot?: SingularOrPluralSnapshot | null;\n    data: any;\n    isMissingData?: boolean;\n    owner?: any;\n};\n\nfunction isMissingData(snapshot: SingularOrPluralSnapshot): boolean {\n    if (Array.isArray(snapshot)) {\n        return snapshot.some((s) => s.isMissingData);\n    }\n    return snapshot.isMissingData;\n}\n\nfunction _getAndSavePromiseForFragmentRequestInFlight(\n    fragmentNode: ReaderFragment,\n    fragmentOwner: RequestDescriptor,\n    env: IEnvironment,\n): Promise<void> | null {\n    let networkPromise = getPromiseForActiveRequest(env, fragmentOwner);\n    let pendingOperationName;\n\n    if (networkPromise != null) {\n        pendingOperationName = fragmentOwner.node.params.name;\n    } else {\n        const result = env.getOperationTracker().getPendingOperationsAffectingOwner(fragmentOwner);\n        const pendingOperations = result?.pendingOperations;\n        networkPromise = result?.promise ?? null;\n        pendingOperationName =\n            pendingOperations?.map((op) => op.node.params.name).join(',') ?? null;\n    }\n\n    if (!networkPromise) {\n        return null;\n    }\n\n    if (pendingOperationName == null || pendingOperationName.length === 0) {\n        pendingOperationName = 'Unknown pending operation';\n    }\n\n    // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n    const fragmentName = fragmentNode.name;\n    const promiseDisplayName =\n        pendingOperationName === fragmentName\n            ? `Relay(${pendingOperationName})`\n            : `Relay(${pendingOperationName}:${fragmentName})`;\n\n    (networkPromise as any).displayName = promiseDisplayName;\n    return networkPromise;\n}\n\nexport class FragmentResolver {\n    _environment: IEnvironment;\n    _fragment: ReaderFragment;\n    _fragmentRef: any;\n    _fragmentRefRefetch: any;\n    _idfragment: any;\n    _idfragmentrefetch: any;\n    resolverData: FragmentResult;\n    _disposable: Disposable;\n    _selector: ReaderSelector;\n    refreshHooks: any;\n    fetcherRefecth: Fetcher;\n    fetcherNext: Fetcher;\n    fetcherPrevious: Fetcher;\n    unmounted = false;\n    name: string;\n    refetchable = false;\n    pagination = false;\n    result: any;\n    _subscribeResolve;\n\n    constructor(name: FragmentNames) {\n        this.name = name;\n        this.pagination = name === PAGINATION_NAME;\n        this.refetchable = name === REFETCHABLE_NAME || this.pagination;\n\n        const setLoading = (_loading): void => this.refreshHooks();\n        if (this.refetchable) {\n            this.fetcherRefecth = fetchResolver({\n                setLoading,\n                doRetain: true,\n            });\n        }\n        if (this.pagination) {\n            this.fetcherNext = fetchResolver({ setLoading });\n            this.fetcherPrevious = fetchResolver({ setLoading });\n        }\n    }\n\n    setForceUpdate(forceUpdate = (): void => undefined): void {\n        this.refreshHooks = (): void => {\n            this.resolveResult();\n            forceUpdate();\n        };\n    }\n\n    subscribeResolve(subscribeResolve: (data: any) => void): void {\n        if (this._subscribeResolve && this._subscribeResolve != subscribeResolve) {\n            subscribeResolve(this.getData());\n        }\n        this._subscribeResolve = subscribeResolve;\n    }\n\n    setUnmounted(): void {\n        this.unmounted = true;\n    }\n\n    isEqualsFragmentRef(prevFragment, fragmentRef): boolean {\n        if (this._fragmentRef !== fragmentRef) {\n            const prevIDs = getDataIDsFromFragment(this._fragment, prevFragment);\n            const nextIDs = getDataIDsFromFragment(this._fragment, fragmentRef);\n            if (\n                !areEqual(prevIDs, nextIDs) ||\n                !areEqual(\n                    this.getFragmentVariables(fragmentRef),\n                    this.getFragmentVariables(prevFragment),\n                )\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    dispose(): void {\n        this.unsubscribe();\n        this.fetcherNext && this.fetcherNext.dispose();\n        this.fetcherPrevious && this.fetcherPrevious.dispose();\n        this._idfragmentrefetch = null;\n        this._fragmentRefRefetch = null;\n        this.fetcherRefecth && this.fetcherRefecth.dispose();\n    }\n\n    getFragmentVariables(fRef = this._fragmentRef): Variables {\n        return getVariablesFromFragment(this._fragment, fRef);\n    }\n\n    resolve(\n        environment: IEnvironment,\n        idfragment: string,\n        fragment: ReaderFragment,\n        fragmentRef,\n    ): void {\n        if (\n            !this.resolverData ||\n            this._environment !== environment ||\n            (idfragment !== this._idfragment &&\n                (!this._idfragmentrefetch ||\n                    (this._idfragmentrefetch && idfragment !== this._idfragmentrefetch)))\n        ) {\n            this._fragment = fragment;\n            this._fragmentRef = fragmentRef;\n            this._idfragment = idfragment;\n            this._selector = null;\n            this.dispose();\n            this._environment = environment;\n            this.lookup(fragment, this._fragmentRef);\n            this.resolveResult();\n        }\n    }\n\n    lookup(fragment, fragmentRef): void {\n        if (fragmentRef == null) {\n            this.resolverData = { data: null };\n            return;\n        }\n        const isPlural =\n            fragment.metadata && fragment.metadata.plural && fragment.metadata.plural === true;\n        if (isPlural) {\n            if (fragmentRef.length === 0) {\n                this.resolverData = { data: [] };\n                return;\n            }\n        }\n        this._selector = getSelector(fragment, fragmentRef);\n        const snapshot = lookupFragment(this._environment, this._selector);\n\n        this.resolverData = getFragmentResult(snapshot);\n        const owner = this._selector\n            ? this._selector.kind === 'PluralReaderSelector'\n                ? (this._selector as any).selectors[0].owner\n                : (this._selector as any).owner\n            : null;\n        this.resolverData.owner = owner;\n        //this.subscribe();\n    }\n\n    checkAndSuspense(suspense): void {\n        if (suspense && this.resolverData.isMissingData && this.resolverData.owner) {\n            const fragmentOwner = this.resolverData.owner;\n            const networkPromise = _getAndSavePromiseForFragmentRequestInFlight(\n                this._fragment,\n                fragmentOwner,\n                this._environment,\n            );\n            const parentQueryName = fragmentOwner.node.params.name ?? 'Unknown Parent Query';\n            if (networkPromise != null) {\n                // When the Promise for the request resolves, we need to make sure to\n                // update the cache with the latest data available in the store before\n                // resolving the Promise\n                const promise = networkPromise\n                    .then(() => {\n                        if (this._idfragmentrefetch) {\n                            this.resolveResult();\n                        } else {\n                            this._idfragment = null;\n                            this.dispose();\n                        }\n                        //;\n                    })\n                    .catch((_error: Error) => {\n                        if (this._idfragmentrefetch) {\n                            this.resolveResult();\n                        } else {\n                            this._idfragment = null;\n                            this.dispose();\n                        }\n                    });\n\n                // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n                (promise as any).displayName = 'Relay(' + parentQueryName + ')';\n                this.unsubscribe();\n                this.refreshHooks = (): void => undefined;\n                throw promise;\n            }\n            warning(\n                false,\n                'Relay: Tried reading fragment `%s` declared in ' +\n                    '`%s`, but it has missing data and its parent query `%s` is not ' +\n                    'being fetched.\\n' +\n                    'This might be fixed by by re-running the Relay Compiler. ' +\n                    ' Otherwise, make sure of the following:\\n' +\n                    '* You are correctly fetching `%s` if you are using a ' +\n                    '\"store-only\" `fetchPolicy`.\\n' +\n                    \"* Other queries aren't accidentally fetching and overwriting \" +\n                    'the data for this fragment.\\n' +\n                    '* Any related mutations or subscriptions are fetching all of ' +\n                    'the data for this fragment.\\n' +\n                    \"* Any related store updaters aren't accidentally deleting \" +\n                    'data for this fragment.',\n                this._fragment.name,\n                this.name,\n                parentQueryName,\n                parentQueryName,\n            );\n        }\n        this.fetcherRefecth && this.fetcherRefecth.checkAndSuspense(suspense);\n    }\n\n    getData(): any | null {\n        return this.result;\n    }\n\n    resolveResult(): any {\n        const { data } = this.resolverData;\n        if (this.refetchable || this.pagination) {\n            const { isLoading, error } = this.fetcherRefecth.getData();\n            const refetch = this.refetch;\n            if (!this.pagination) {\n                // useRefetchable\n                if ('production' !== process.env.NODE_ENV) {\n                    getRefetchMetadata(this._fragment, this.name);\n                }\n                this.result = {\n                    data,\n                    isLoading,\n                    error,\n                    refetch,\n                };\n            } else {\n                // usePagination\n                const { connectionPathInFragmentData } = getPaginationMetadata(\n                    this._fragment,\n                    this.name,\n                );\n\n                const connection = getValueAtPath(data, connectionPathInFragmentData);\n                const { hasMore: hasNext } = getStateFromConnection(\n                    'forward',\n                    this._fragment,\n                    connection,\n                );\n                const { hasMore: hasPrevious } = getStateFromConnection(\n                    'backward',\n                    this._fragment,\n                    connection,\n                );\n                const { isLoading: isLoadingNext, error: errorNext } = this.fetcherNext.getData();\n                const {\n                    isLoading: isLoadingPrevious,\n                    error: errorPrevious,\n                } = this.fetcherPrevious.getData();\n                this.result = {\n                    data,\n                    hasNext,\n                    isLoadingNext,\n                    hasPrevious,\n                    isLoadingPrevious,\n                    isLoading,\n                    errorNext,\n                    errorPrevious,\n                    error,\n                    refetch,\n                    loadNext: this.loadNext,\n                    loadPrevious: this.loadPrevious,\n                };\n            }\n        } else {\n            // useFragment\n            this.result = data;\n        }\n        this._subscribeResolve && this._subscribeResolve(this.result);\n    }\n\n    unsubscribe(): void {\n        this._disposable && this._disposable.dispose();\n    }\n\n    subscribe(): void {\n        const environment = this._environment;\n        const renderedSnapshot = this.resolverData.snapshot;\n        this.unsubscribe();\n        const dataSubscriptions = [];\n        if (renderedSnapshot) {\n            if (Array.isArray(renderedSnapshot)) {\n                renderedSnapshot.forEach((snapshot, idx) => {\n                    dataSubscriptions.push(\n                        environment.subscribe(snapshot, (latestSnapshot) => {\n                            this.resolverData.snapshot[idx] = latestSnapshot;\n                            this.resolverData.data[idx] = latestSnapshot.data;\n                            this.resolverData.isMissingData = false;\n                            this.refreshHooks();\n                        }),\n                    );\n                });\n            } else {\n                dataSubscriptions.push(\n                    environment.subscribe(renderedSnapshot, (latestSnapshot) => {\n                        this.resolverData = getFragmentResult(latestSnapshot);\n                        this.resolverData.isMissingData = false;\n                        this.refreshHooks();\n                    }),\n                );\n            }\n        }\n\n        this._disposable = {\n            dispose: (): void => {\n                dataSubscriptions.map((s) => s.dispose());\n                this._disposable = undefined;\n            },\n        };\n    }\n\n    refetch = (variables: Variables, options?: Options): Disposable => {\n        if (this.unmounted === true) {\n            warning(\n                false,\n                'Relay: Unexpected call to `refetch` on unmounted component for fragment ' +\n                    '`%s` in `%s`. It looks like some instances of your component are ' +\n                    'still trying to fetch data but they already unmounted. ' +\n                    'Please make sure you clear all timers, intervals, ' +\n                    'async calls, etc that may trigger a fetch.',\n                this._fragment.name,\n                this.name,\n            );\n            return { dispose: (): void => {} };\n        }\n        if (this._selector == null) {\n            warning(\n                false,\n                'Relay: Unexpected call to `refetch` while using a null fragment ref ' +\n                    'for fragment `%s` in `%s`. When calling `refetch`, we expect ' +\n                    \"initial fragment data to be non-null. Please make sure you're \" +\n                    'passing a valid fragment ref to `%s` before calling ' +\n                    '`refetch`, or make sure you pass all required variables to `refetch`.',\n                this._fragment.name,\n                this.name,\n                this.name,\n            );\n        }\n\n        const {\n            fragmentRefPathInResponse,\n            identifierField,\n            refetchableRequest,\n        } = getRefetchMetadata(this._fragment, this.name);\n        const fragmentData = this.getData().data;\n        const identifierValue =\n            identifierField != null && fragmentData != null && typeof fragmentData === 'object'\n                ? fragmentData[identifierField]\n                : null;\n\n        let parentVariables;\n        let fragmentVariables;\n        if (this._selector == null) {\n            parentVariables = {};\n            fragmentVariables = {};\n        } else if (this._selector.kind === 'PluralReaderSelector') {\n            parentVariables =\n                (this._selector as PluralReaderSelector).selectors[0]?.owner.variables ?? {};\n            fragmentVariables =\n                (this._selector as PluralReaderSelector).selectors[0]?.variables ?? {};\n        } else {\n            parentVariables = (this._selector as SingularReaderSelector).owner.variables;\n            fragmentVariables = (this._selector as SingularReaderSelector).variables;\n        }\n\n        // NOTE: A user of `useRefetchableFragment()` may pass a subset of\n        // all variables required by the fragment when calling `refetch()`.\n        // We fill in any variables not passed by the call to `refetch()` with the\n        // variables from the original parent fragment owner.\n        /* $FlowFixMe[cannot-spread-indexer] (>=0.123.0) This comment suppresses\n         * an error found when Flow v0.123.0 was deployed. To see the error\n         * delete this comment and run Flow. */\n        const refetchVariables = {\n            ...parentVariables,\n            /* $FlowFixMe[exponential-spread] (>=0.111.0) This comment suppresses\n             * an error found when Flow v0.111.0 was deployed. To see the error,\n             * delete this comment and run Flow. */\n            ...fragmentVariables,\n            ...variables,\n        };\n\n        if (identifierField != null && !variables.hasOwnProperty('id')) {\n            // @refetchable fragments are guaranteed to have an `id` selection\n            // if the type is Node, implements Node, or is @fetchable. Double-check\n            // that there actually is a value at runtime.\n            if (typeof identifierValue !== 'string') {\n                warning(\n                    false,\n                    'Relay: Expected result to have a string  ' +\n                        '`%s` in order to refetch, got `%s`.',\n                    identifierField,\n                    identifierValue,\n                );\n            }\n            refetchVariables.id = identifierValue;\n        }\n\n        const onNext = (operation: OperationDescriptor, snapshot: Snapshot): void => {\n            const fragmentRef = getValueAtPath(snapshot.data, fragmentRefPathInResponse);\n            const isEquals = this.isEqualsFragmentRef(\n                this._fragmentRefRefetch || this._fragmentRef,\n                fragmentRef,\n            );\n            const missData = isMissingData(snapshot); //fromStore && isMissingData(snapshot);\n            if (!isEquals || missData) {\n                this._fragmentRefRefetch = fragmentRef;\n                this._idfragmentrefetch = getFragmentIdentifier(this._fragment, fragmentRef);\n                this.lookup(this._fragment, fragmentRef);\n                this.subscribe();\n                /*if (!missData) {\n                    this.subscribe();\n                }*/\n                this.resolverData.isMissingData = missData;\n                this.resolverData.owner = operation.request;\n                this.refreshHooks();\n            }\n        };\n        if (this.pagination) {\n            this.fetcherNext.dispose();\n            this.fetcherPrevious.dispose();\n        }\n        const operation = createOperation(refetchableRequest, refetchVariables, forceCache);\n        return this.fetcherRefecth.fetch(\n            this._environment,\n            operation,\n            options?.fetchPolicy,\n            options?.onComplete,\n            onNext,\n            options?.UNSTABLE_renderPolicy,\n        );\n    };\n\n    loadPrevious = (count: number, options?: OptionsLoadMore): Disposable => {\n        return this.loadMore('backward', count, options);\n    };\n\n    loadNext = (count: number, options?: OptionsLoadMore): Disposable => {\n        return this.loadMore('forward', count, options);\n    };\n\n    loadMore = (\n        direction: 'backward' | 'forward',\n        count: number,\n        options?: OptionsLoadMore,\n    ): Disposable => {\n        const onComplete = options?.onComplete ?? ((): void => undefined);\n\n        const fragmentData = this.getData().data;\n\n        const fetcher = direction === 'backward' ? this.fetcherPrevious : this.fetcherNext;\n        if (this.unmounted === true) {\n            // Bail out and warn if we're trying to paginate after the component\n            // has unmounted\n            warning(\n                false,\n                'Relay: Unexpected fetch on unmounted component for fragment ' +\n                    '`%s` in `%s`. It looks like some instances of your component are ' +\n                    'still trying to fetch data but they already unmounted. ' +\n                    'Please make sure you clear all timers, intervals, ' +\n                    'async calls, etc that may trigger a fetch.',\n                this._fragment.name,\n                this.name,\n            );\n            return { dispose: (): void => {} };\n        }\n        if (this._selector == null) {\n            warning(\n                false,\n                'Relay: Unexpected fetch while using a null fragment ref ' +\n                    'for fragment `%s` in `%s`. When fetching more items, we expect ' +\n                    \"initial fragment data to be non-null. Please make sure you're \" +\n                    'passing a valid fragment ref to `%s` before paginating.',\n                this._fragment.name,\n                this.name,\n                this.name,\n            );\n            onComplete(null);\n            return { dispose: (): void => {} };\n        }\n        const isRequestActive = (this._environment as any).isRequestActive(\n            (this._selector as SingularReaderSelector).owner.identifier,\n        );\n        if (isRequestActive || fetcher.getData().isLoading === true || fragmentData == null) {\n            onComplete(null);\n            return { dispose: (): void => {} };\n        }\n        invariant(\n            this._selector != null && this._selector.kind !== 'PluralReaderSelector',\n            'Relay: Expected to be able to find a non-plural fragment owner for ' +\n                \"fragment `%s` when using `%s`. If you're seeing this, \" +\n                'this is likely a bug in Relay.',\n            this._fragment.name,\n            this.name,\n        );\n\n        const {\n            paginationRequest,\n            paginationMetadata,\n            identifierField,\n            connectionPathInFragmentData,\n        } = getPaginationMetadata(this._fragment, this.name);\n        const identifierValue =\n            identifierField != null && fragmentData != null && typeof fragmentData === 'object'\n                ? fragmentData[identifierField]\n                : null;\n\n        const parentVariables = (this._selector as SingularReaderSelector).owner.variables;\n        const fragmentVariables = (this._selector as SingularReaderSelector).variables;\n        const extraVariables = options?.UNSTABLE_extraVariables;\n        const baseVariables = {\n            ...parentVariables,\n            ...fragmentVariables,\n        };\n        const { cursor } = getConnectionState(\n            direction,\n            this._fragment,\n            fragmentData,\n            connectionPathInFragmentData,\n        );\n        const paginationVariables = getPaginationVariables(\n            direction,\n            count,\n            cursor,\n            baseVariables,\n            { ...extraVariables },\n            paginationMetadata,\n        );\n\n        // If the query needs an identifier value ('id' or similar) and one\n        // was not explicitly provided, read it from the fragment data.\n        if (identifierField != null) {\n            // @refetchable fragments are guaranteed to have an `id` selection\n            // if the type is Node, implements Node, or is @fetchable. Double-check\n            // that there actually is a value at runtime.\n            if (typeof identifierValue !== 'string') {\n                warning(\n                    false,\n                    'Relay: Expected result to have a string  ' +\n                        '`%s` in order to refetch, got `%s`.',\n                    identifierField,\n                    identifierValue,\n                );\n            }\n            paginationVariables.id = identifierValue;\n        }\n\n        const onNext = (): void => {};\n\n        const operation = createOperation(paginationRequest, paginationVariables, forceCache);\n        return fetcher.fetch(\n            this._environment,\n            operation,\n            undefined, //options?.fetchPolicy,\n            onComplete,\n            onNext,\n        );\n    };\n}\n","import * as warning from 'fbjs/lib/warning';\nimport { useEffect, useRef, useMemo } from 'react';\nimport { GraphQLTaggedNode, getFragmentIdentifier, getFragment } from 'relay-runtime';\nimport { FragmentResolver } from './FragmentResolver';\nimport { FragmentNames } from './RelayHooksTypes';\nimport { useForceUpdate } from './useForceUpdate';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useOssFragment(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: any | null,\n    suspense: boolean,\n    name: FragmentNames,\n    subscribeResolve?: (data: any) => void,\n): any {\n    const environment = useRelayEnvironment();\n    const forceUpdate = useForceUpdate();\n    const ref = useRef<{ resolver: FragmentResolver }>(null);\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            resolver: new FragmentResolver(name),\n        };\n    }\n\n    const { resolver } = ref.current;\n\n    useEffect(() => {\n        return (): void => {\n            ref.current.resolver.setUnmounted();\n        };\n    }, []);\n\n    useEffect(() => {\n        return (): void => {\n            resolver.dispose();\n        };\n    }, [resolver]);\n\n    const fragment = useMemo(() => {\n        return getFragment(fragmentNode);\n    }, [fragmentNode]);\n\n    const idfragment = useMemo(() => {\n        return getFragmentIdentifier(fragment, fragmentRef);\n    }, [fragment, fragmentRef]);\n\n    useEffect(() => {\n        resolver.subscribe();\n        return (): void => {\n            resolver.unsubscribe();\n        };\n    }, [resolver, idfragment, environment]);\n\n    resolver.subscribeResolve(subscribeResolve);\n\n    resolver.resolve(environment, idfragment, fragment, fragmentRef);\n    if (subscribeResolve) {\n        resolver.setForceUpdate();\n        return;\n    }\n\n    resolver.checkAndSuspense(suspense);\n    resolver.setForceUpdate(forceUpdate);\n\n    const data = resolver.getData();\n\n    if ('production' !== process.env.NODE_ENV) {\n        if (\n            fragmentRef != null &&\n            (data === undefined ||\n                (Array.isArray(data) &&\n                    data.length > 0 &&\n                    data.every((data) => data === undefined)))\n        ) {\n            warning(\n                false,\n                'Relay: Expected to have been able to read non-null data for ' +\n                    'fragment `%s` declared in ' +\n                    '`%s`, since fragment reference was non-null. ' +\n                    \"Make sure that that `%s`'s parent isn't \" +\n                    'holding on to and/or passing a fragment reference for data that ' +\n                    'has been deleted.',\n                fragment,\n                name,\n                name,\n            );\n        }\n    }\n\n    return [data, resolver];\n}\n","import { GraphQLTaggedNode } from 'relay-runtime';\nimport {\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n    FRAGMENT_NAME,\n} from './RelayHooksTypes';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): $Call<KeyReturnType<TKey>>;\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): $Call<KeyReturnType<TKey>> | null;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, false, FRAGMENT_NAME);\n    return data;\n}\n\nexport function useSuspenseFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): $Call<KeyReturnType<TKey>>;\nexport function useSuspenseFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): $Call<KeyReturnType<TKey>> | null;\nexport function useSuspenseFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\nexport function useSuspenseFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, true, FRAGMENT_NAME);\n    return data;\n}\n\nexport function useFragmentSubscription<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: $Call<KeyReturnType<TKey>>) => void,\n): void;\nexport function useFragmentSubscription<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: $Call<KeyReturnType<TKey>> | null) => void,\n): void;\nexport function useFragmentSubscription<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>) => void,\n): void;\nexport function useFragmentSubscription<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>) => void,\n): void {\n    useOssFragment(fragmentNode, fragmentRef, false, FRAGMENT_NAME, callback);\n}\n","import useMounted from '@restart/hooks/useMounted';\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as React from 'react';\nimport { Environment, MutationParameters, commitMutation } from 'relay-runtime';\nimport {\n    MutationNode,\n    MutationConfig,\n    MutationConfigWithoutVariables,\n    MutationState,\n    Mutate,\n    MutateWithVariables,\n} from './RelayHooksTypes';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nconst { useCallback, useState } = React;\n\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig?: MutationConfigWithoutVariables<T>,\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [MutateWithVariables<T>, MutationState<T>];\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig?: MutationConfig<T>,\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [Mutate<T>, MutationState<T>];\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig: MutationConfig<T> = {},\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [Mutate<T>, MutationState<T>] {\n    const [state, setState] = useState<MutationState<T>>({\n        loading: false,\n        data: null,\n        error: null,\n    });\n\n    const isMounted = useMounted();\n\n    const relayEnvironment = useRelayEnvironment();\n    const resolvedEnvironment = environment || relayEnvironment;\n    const {\n        configs,\n        variables,\n        uploadables,\n        onCompleted,\n        onError,\n        optimisticUpdater,\n        optimisticResponse,\n        updater,\n    } = userConfig;\n\n    const mutate: Mutate<T> = useCallback(\n        (config) => {\n            const mergedConfig = {\n                configs,\n                variables,\n                uploadables,\n                onCompleted,\n                onError,\n                optimisticUpdater,\n                optimisticResponse,\n                updater,\n                ...config,\n            };\n\n            invariant(mergedConfig.variables, 'you must specify variables');\n\n            if (isMounted()) {\n                setState({\n                    loading: true,\n                    data: mergedConfig.optimisticResponse,\n                    error: null,\n                });\n            }\n\n            return new Promise((resolve, reject) => {\n                function handleError(error: any): void {\n                    if (isMounted()) {\n                        setState({\n                            loading: false,\n                            data: null,\n                            error,\n                        });\n                    }\n\n                    if (mergedConfig.onError) {\n                        mergedConfig.onError(error);\n                        resolve(null);\n                    } else {\n                        reject(error);\n                    }\n                }\n\n                commitMutation(resolvedEnvironment, {\n                    ...mergedConfig,\n                    mutation,\n                    variables: mergedConfig.variables,\n                    onCompleted: (response, errors) => {\n                        if (errors) {\n                            // FIXME: This isn't right. onError expects a single error.\n                            handleError(errors);\n                            return;\n                        }\n\n                        if (isMounted()) {\n                            setState({\n                                loading: false,\n                                data: response,\n                                error: null,\n                            });\n                        }\n\n                        if (mergedConfig.onCompleted) {\n                            mergedConfig.onCompleted(response);\n                        }\n                        resolve(response);\n                    },\n                    onError: handleError,\n                });\n            });\n        },\n        [\n            resolvedEnvironment,\n            configs,\n            mutation,\n            variables,\n            uploadables,\n            onCompleted,\n            onError,\n            optimisticUpdater,\n            optimisticResponse,\n            updater,\n            isMounted,\n        ],\n    );\n\n    return [mutate, state];\n}\n","import { useEffect } from 'react';\nimport { GraphQLSubscriptionConfig, requestSubscription, OperationType } from 'relay-runtime';\nimport {\n    SkipGraphQLSubscriptionConfig,\n    SkipSubscriptionConfig,\n    SubscriptionConfig,\n} from './RelayHooksTypes';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\n    opts?: SubscriptionConfig,\n): void;\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: SkipGraphQLSubscriptionConfig<TSubscriptionPayload>,\n    opts: SkipSubscriptionConfig,\n): void;\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\n    opts?: SubscriptionConfig,\n): void {\n    const environment = useRelayEnvironment();\n    const skip = opts && opts.skip;\n\n    useEffect(() => {\n        if (skip) {\n            return;\n        }\n        const { dispose } = requestSubscription(environment, config);\n        return dispose;\n    }, [environment, config, skip]);\n}\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    KeyType,\n    KeyTypeData,\n    PAGINATION_NAME,\n    ReturnTypePagination,\n    ReturnTypePaginationSuspense,\n} from './RelayHooksTypes';\nimport { useOssFragment } from './useOssFragment';\n\nexport function usePagination<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePagination<TQuery, TKey, KeyTypeData<TKey>>;\nexport function usePagination<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePagination<TQuery, TKey | null, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, false, PAGINATION_NAME);\n    return data;\n}\n\nexport function usePaginationFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePaginationSuspense<TQuery, TKey, KeyTypeData<TKey>>;\nexport function usePaginationFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePaginationSuspense<TQuery, TKey | null, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, true, PAGINATION_NAME);\n    return data;\n}\n\nexport function usePaginationSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: ReturnTypePagination<TQuery, TKey, KeyTypeData<TKey>>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid;\nexport function usePaginationSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: ReturnTypePagination<TQuery, TKey | null, KeyTypeData<TKey> | null>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid {\n    useOssFragment(fragmentNode, fragmentRef, false, PAGINATION_NAME, callback);\n}\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    KeyType,\n    KeyTypeData,\n    REFETCHABLE_NAME,\n    ReturnTypeRefetchNode,\n    ReturnTypeRefetchSuspenseNode,\n} from './RelayHooksTypes';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useRefetchable<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey>>;\nexport function useRefetchable<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentInput, fragmentRef, false, REFETCHABLE_NAME);\n    return data;\n}\n\nexport function useRefetchableFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchSuspenseNode<TQuery, TKey, KeyTypeData<TKey>>;\nexport function useRefetchableFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchSuspenseNode<TQuery, TKey, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentInput, fragmentRef, true, REFETCHABLE_NAME);\n    return data;\n}\n\nexport function useRefetchableSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: ReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey>>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid;\nexport function useRefetchableSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: ReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey> | null>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid {\n    useOssFragment(fragmentInput, fragmentRef, false, REFETCHABLE_NAME, callback);\n}\n","import * as React from 'react';\nimport { Environment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nexport const RelayEnvironmentProvider = function<\n    TEnvironment extends Environment = Environment\n>(props: { children: React.ReactNode; environment: TEnvironment }): JSX.Element {\n    const context = React.useMemo(() => ({ environment: props.environment }), [props.environment]);\n    return (\n        <ReactRelayContext.Provider value={context}>{props.children}</ReactRelayContext.Provider>\n    );\n};\n"],"names":["createRelayContext","ReactRelayContext","React","NETWORK_ONLY","STORE_THEN_NETWORK","STORE_OR_NETWORK","STORE_ONLY","PAGINATION_NAME","REFETCHABLE_NAME","FRAGMENT_NAME","FORWARD","isNetworkPolicy","policy","full","isStorePolicy","forceCache","force","createOperation","gqlQuery","variables","cacheConfig","createOperationDescriptor","getRequest","fetchQuery","DATA_RETENTION_TIMEOUT","fetchResolver","_a","setLoading","_b","doRetain","disposeTemporary","_refetchSubscription","disposable","releaseQueryTimeout","isLoading","query","promise","error","env","updateLoading","loading","lookupInStore","environment","operation","fetchPolicy","renderPolicy","check","queryStatus","status","hasFullQuery","canPartialRender","snapshot","lookup","fragment","dispose","clearTemporaryRetain","disposeRequest","clearTimeout","temporaryRetain","localReleaseTemporaryRetain","setTimeout","unsubscribe","fetch","onComplete","onNext","_e","undefined","request","identifier","retain","isNetwork","onlyStore","resolveNetworkPromise_1","refetchSubscription_1","cleanup_1","subscribe","complete","e","next","store","poll","start","subscription","Promise","resolve","checkAndSuspense","suspense","useLazy","toThrow","getData","defaultPolicy","cache","Map","getOrCreateQueryFetcher","networkCacheConfig","toGet","has","queryFetcher","get","QueryFetcher","setQuery","emptyforceUpdate","cacheConfigOverride","options","_this","node","resolveResult","forceUpdate","result","retry","data","fetcher","delete","disposeSnapshot","rootSubscription","skip","fetchHasReturned","_o","areEqual","getQuery","fetchKey","diffQuery","setForceUpdate","set","useForceUpdate","useRelayEnvironment","useInternalQuery","ref","useRef","current","useEffect","useQuery","useLazyLoadQuery","emptyFunction","internalLoadQuery","Error","reject","getValue","resolveEnvironment","callback","getForceUpdate","loadLazyQuery","loadQuery","usePreloadedQuery","getValueAtPath","path","path_1","_i","key","Array","isArray","invariant","getStateFromConnection","direction","fragmentNode","connection","cursor","hasMore","_c","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","END_CURSOR","START_CURSOR","name","edges","pageInfo","getConnectionState","fragmentData","connectionPathInFragmentData","getRefetchMetadata","componentDisplayName","metadata","plural","refetchMetadata","refetch","refetchableRequest","default","fragmentRefPathInResponse","fragmentPathInResult","identifierField","getPaginationMetadata","paginationRequest","paginationMetadata","connectionMetadata","stream","getPaginationVariables","count","baseVariables","extraVariables","backwardMetadata","forwardMetadata","warning","hasOwnProperty","paginationVariables_1","paginationVariables","getPromiseForActiveRequest","lookupFragment","selector","kind","selectors","map","s","getFragmentResult","missData","isMissingData","some","_getAndSavePromiseForFragmentRequestInFlight","fragmentOwner","networkPromise","pendingOperationName","params","getOperationTracker","getPendingOperationsAffectingOwner","pendingOperations","op","join","length","fragmentName","promiseDisplayName","displayName","unmounted","_fragment","_selector","identifierValue","parentVariables","fragmentVariables","owner","refetchVariables","id","fragmentRef","isEquals","isEqualsFragmentRef","_fragmentRefRefetch","_fragmentRef","_idfragmentrefetch","getFragmentIdentifier","resolverData","refreshHooks","pagination","fetcherNext","fetcherPrevious","fetcherRefecth","_environment","UNSTABLE_renderPolicy","loadMore","isRequestActive","UNSTABLE_extraVariables","refetchable","_loading","FragmentResolver","subscribeResolve","_subscribeResolve","prevFragment","prevIDs","getDataIDsFromFragment","nextIDs","getFragmentVariables","fRef","getVariablesFromFragment","idfragment","_idfragment","isPlural","getSelector","parentQueryName","then","catch","_error","hasNext","hasPrevious","isLoadingNext","errorNext","isLoadingPrevious","errorPrevious","loadNext","loadPrevious","_disposable","renderedSnapshot","dataSubscriptions","forEach","idx","push","latestSnapshot","useOssFragment","resolver","setUnmounted","useMemo","getFragment","every","useFragment","useSuspenseFragment","useFragmentSubscription","useCallback","useState","useMutation","mutation","userConfig","state","setState","isMounted","useMounted","relayEnvironment","resolvedEnvironment","configs","uploadables","onCompleted","onError","optimisticUpdater","optimisticResponse","updater","mutate","config","mergedConfig","handleError","commitMutation","response","errors","useSubscription","opts","usePagination","usePaginationFragment","usePaginationSubscription","useRefetchable","fragmentInput","useRefetchableFragment","useRefetchableSubscription","RelayEnvironmentProvider","props","context","Provider","value","children"],"mappings":"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"}