{"version":3,"file":"relay-hooks.min.js","sources":["../../src/ReactRelayContext.ts","../../src/Utils.ts","../../src/FetchResolver.ts","../../src/RelayHooksTypes.ts","../../src/QueryFetcher.ts","../../src/useForceUpdate.ts","../../src/useRelayEnvironment.ts","../../src/useQuery.ts","../../src/loadQuery.ts","../../node_modules/tslib/tslib.es6.js","../../src/getValueAtPath.ts","../../src/getConnectionState.ts","../../src/getRefetchMetadata.ts","../../src/getPaginationMetadata.ts","../../src/FragmentResolver.ts","../../src/getPaginationVariables.ts","../../src/useOssFragment.tsx","../../src/useMutation.ts","../../src/RelayEnvironmentProvider.tsx","../../src/useFragment.tsx","../../src/usePagination.ts","../../src/usePreloadedQuery.ts","../../src/useRefetchable.ts","../../src/useSubscription.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport * as React from 'react';\nimport { __internal } from 'relay-runtime';\n\nconst { createRelayContext } = __internal as any;\n\nexport const ReactRelayContext = createRelayContext(React);\n","import {\n    Variables,\n    ConnectionMetadata,\n    createOperationDescriptor,\n    getRequest,\n    GraphQLTaggedNode,\n    OperationDescriptor,\n    CacheConfig,\n} from 'relay-runtime';\nimport { STORE_OR_NETWORK, STORE_THEN_NETWORK, NETWORK_ONLY, FetchPolicy } from './RelayHooksTypes';\n\nexport type ReactConnectionMetadata = ConnectionMetadata & { fragmentName: string };\n\nexport const isNetworkPolicy = (policy: FetchPolicy, full: boolean): boolean => {\n    return (\n        policy === NETWORK_ONLY ||\n        policy === STORE_THEN_NETWORK ||\n        (policy === STORE_OR_NETWORK && !full)\n    );\n};\n\nexport const isStorePolicy = (policy: FetchPolicy): boolean => {\n    return policy !== NETWORK_ONLY;\n};\n\nexport const forceCache = { force: true };\n\n// Fetcher\nexport function createOperation(\n    gqlQuery: GraphQLTaggedNode,\n    variables: Variables,\n    cacheConfig?: CacheConfig | null,\n): OperationDescriptor {\n    return createOperationDescriptor(getRequest(gqlQuery), variables, cacheConfig);\n}\n","import {\n    __internal,\n    Disposable,\n    FetchPolicy,\n    Subscription,\n    OperationDescriptor,\n    IEnvironment,\n    Snapshot,\n    RenderPolicy,\n} from 'relay-runtime';\nimport { isNetworkPolicy, isStorePolicy } from './Utils';\nconst { fetchQuery } = __internal;\nconst DATA_RETENTION_TIMEOUT = 30 * 1000;\n\nexport type Fetcher = {\n    fetch: (\n        environment: IEnvironment,\n        operation: OperationDescriptor,\n        fetchPolicy: FetchPolicy | null | undefined,\n        onComplete: (_e: Error | null) => void,\n        onNext: (\n            operation: OperationDescriptor,\n            snapshot: Snapshot,\n            fromStore?: boolean,\n            onlyStore?: boolean,\n        ) => void,\n        renderPolicy?: RenderPolicy,\n    ) => Disposable;\n    getData: () => {\n        isLoading: boolean;\n        error?: Error | null;\n    };\n    dispose: () => void;\n    checkAndSuspense: (suspense: boolean, useLazy?: boolean) => Promise<any> | Error | null;\n};\n\nexport function fetchResolver({\n    setLoading,\n    doRetain = true,\n    disposeTemporary,\n}: {\n    doRetain?: boolean;\n    setLoading?: (loading: boolean) => void;\n    disposeTemporary?: () => void;\n}): Fetcher {\n    let _refetchSubscription: Subscription | null = null;\n    let disposable: Disposable | null = null;\n    let releaseQueryTimeout;\n    let isLoading = false;\n    let query;\n    let promise: Promise<any>;\n    let error: Error | null = null;\n    let env;\n\n    const updateLoading = (loading: boolean): void => {\n        isLoading = loading;\n        setLoading && setLoading(isLoading);\n    };\n    const lookupInStore = (\n        environment: IEnvironment,\n        operation,\n        fetchPolicy,\n        renderPolicy: RenderPolicy,\n    ): { snapshot: Snapshot | null; full: boolean } => {\n        if (isStorePolicy(fetchPolicy)) {\n            const check = environment.check(operation);\n            const queryStatus = check.status;\n            const hasFullQuery = queryStatus === 'available';\n            const canPartialRender =\n                hasFullQuery || (renderPolicy === 'partial' && queryStatus !== 'stale');\n            if (canPartialRender) {\n                return { snapshot: environment.lookup(operation.fragment), full: hasFullQuery };\n            }\n        }\n        return { snapshot: null, full: false };\n    };\n\n    const dispose = (): void => {\n        clearTemporaryRetain();\n        disposable && disposable.dispose();\n        disposeRequest();\n        disposable = null;\n        env = null;\n        query = null;\n    };\n\n    const clearTemporaryRetain = (): void => {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n    };\n\n    const temporaryRetain = (): void => {\n        const localReleaseTemporaryRetain = (): void => {\n            clearTemporaryRetain();\n            dispose();\n            disposeTemporary && disposeTemporary();\n        };\n        releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT);\n    };\n\n    const disposeRequest = (): void => {\n        _refetchSubscription && _refetchSubscription.unsubscribe();\n        error = null;\n    };\n\n    const fetch = (\n        environment: IEnvironment,\n        operation: OperationDescriptor,\n        fetchPolicy: FetchPolicy = 'network-only',\n        onComplete = (_e: Error | null): void => undefined,\n        onNext: (\n            operation: OperationDescriptor,\n            snapshot: Snapshot,\n            fromStore?: boolean,\n            onlyStore?: boolean,\n        ) => void,\n        renderPolicy?: RenderPolicy,\n    ): Disposable => {\n        if (env != environment || query.request.identifier !== operation.request.identifier) {\n            dispose();\n            if (doRetain) {\n                disposable = environment.retain(operation);\n            }\n        }\n        env = environment;\n        query = operation;\n\n        disposeRequest();\n        const { snapshot, full } = lookupInStore(environment, operation, fetchPolicy, renderPolicy);\n        const isNetwork = isNetworkPolicy(fetchPolicy, full);\n        if (snapshot != null) {\n            const onlyStore = !isNetwork;\n            onNext(operation, snapshot, true, onlyStore);\n            if (onlyStore) {\n                onComplete(null);\n            }\n        }\n        // Cancel any previously running refetch.\n        _refetchSubscription && _refetchSubscription.unsubscribe();\n        if (isNetwork) {\n            let resolveNetworkPromise = (): void => {};\n\n            // Declare refetchSubscription before assigning it in .start(), since\n            // synchronous completion may call callbacks .subscribe() returns.\n            let refetchSubscription: Subscription;\n            const cleanup = (): void => {\n                if (_refetchSubscription === refetchSubscription) {\n                    _refetchSubscription = null;\n                }\n                isLoading = false;\n                promise = null;\n            };\n\n            fetchQuery(environment, operation).subscribe({\n                unsubscribe: (): void => {\n                    cleanup();\n                },\n                complete: (): void => {\n                    resolveNetworkPromise();\n                    updateLoading(false);\n                    cleanup();\n                    onComplete(null);\n                },\n                error: (e: Error): void => {\n                    error = e;\n                    resolveNetworkPromise();\n                    updateLoading(false);\n                    cleanup();\n                    onComplete(e);\n                },\n                next: () => {\n                    const store = environment.lookup(operation.fragment);\n                    promise = null;\n                    operation.request.cacheConfig?.poll && updateLoading(false);\n                    resolveNetworkPromise();\n                    onNext(operation, store);\n                },\n                start: (subscription) => {\n                    refetchSubscription = subscription;\n                    _refetchSubscription = refetchSubscription;\n                    updateLoading(true);\n                },\n            });\n            if (!snapshot) {\n                promise = new Promise((resolve: any) => {\n                    resolveNetworkPromise = resolve;\n                });\n            }\n            return {\n                dispose: (): void => {\n                    refetchSubscription && refetchSubscription.unsubscribe();\n                },\n            };\n        }\n        return {\n            dispose: (): void => {},\n        };\n    };\n\n    const checkAndSuspense = (suspense, useLazy): Promise<any> | Error | null => {\n        clearTemporaryRetain();\n        const toThrow = promise || error;\n        if (suspense && toThrow) {\n            if (promise && useLazy) {\n                temporaryRetain();\n            }\n            throw toThrow;\n        }\n        return toThrow;\n    };\n\n    const getData = (): {\n        isLoading: boolean;\n        error?: Error | null;\n    } => {\n        return {\n            isLoading,\n            error,\n        };\n    };\n\n    return {\n        fetch,\n        getData,\n        dispose,\n        checkAndSuspense,\n    };\n}\n","import {\n    Disposable,\n    OperationType,\n    CacheConfig,\n    GraphQLTaggedNode,\n    IEnvironment,\n    MutationConfig as BaseMutationConfig,\n    MutationParameters,\n    FragmentSpecResolver,\n    VariablesOf,\n    FragmentReference,\n    RenderPolicy,\n    GraphQLSubscriptionConfig,\n} from 'relay-runtime';\n\nexport type MutationState<T extends MutationParameters> = {\n    loading: boolean;\n    data: T['response'] | null;\n    error?: Error | null;\n};\n\nexport type MutationNode<T extends MutationParameters> = BaseMutationConfig<T>['mutation'];\n\nexport type MutationConfig<T extends MutationParameters> = Partial<\n    Omit<BaseMutationConfig<T>, 'mutation' | 'onCompleted'>\n> & {\n    onCompleted?(response: T['response']): void;\n};\n\nexport type MutationConfigWithoutVariables<T extends MutationParameters> = Omit<\n    MutationConfig<T>,\n    'variables'\n>;\n\nexport type Mutate<T extends MutationParameters> = (\n    config?: Partial<MutationConfig<T>>,\n) => Promise<T['response']>;\n\nexport type MutateWithVariables<T extends MutationParameters> = (\n    config: Partial<MutationConfig<T>> & { variables: T['variables'] },\n) => Promise<T['response']>;\n\nexport const NETWORK_ONLY = 'network-only';\nexport const STORE_THEN_NETWORK = 'store-and-network';\nexport const STORE_OR_NETWORK = 'store-or-network';\nexport const STORE_ONLY = 'store-only';\n\nexport const PAGINATION_NAME = 'usePagination';\nexport const REFETCHABLE_NAME = 'useRefetchable';\nexport const FRAGMENT_NAME = 'useFragment';\n\nexport type FragmentNames = typeof PAGINATION_NAME | typeof REFETCHABLE_NAME | typeof FRAGMENT_NAME;\n\nexport type FetchPolicy =\n    | typeof STORE_ONLY\n    | typeof STORE_OR_NETWORK\n    | typeof STORE_THEN_NETWORK\n    | typeof NETWORK_ONLY;\n\nexport type ContainerResult = {\n    data: { [key: string]: any };\n    resolver: FragmentSpecResolver;\n};\n\nexport interface RenderProps<T extends OperationType> {\n    error: Error | null;\n    data: T['response'] | null | undefined;\n    retry: (_cacheConfigOverride?: CacheConfig, options?: Options) => void;\n    isLoading: boolean;\n}\n\nexport type QueryOptions = {\n    fetchPolicy?: FetchPolicy;\n    fetchKey?: string | number;\n    networkCacheConfig?: CacheConfig;\n    skip?: boolean;\n    onComplete?: (_e: Error | null) => void;\n    UNSTABLE_renderPolicy?: RenderPolicy;\n};\n\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (arg: any) => infer RT\n    ? RT\n    : never;\n\nexport type KeyType<TData = unknown> = Readonly<{\n    ' $data'?: TData;\n    ' $fragmentRefs': FragmentReference;\n}>;\nexport type ArrayKeyType = ReadonlyArray<{ readonly ' $data'?: ReadonlyArray<unknown> } | null>;\n\nexport type KeyTypeData<TKey extends KeyType<TData>, TData = unknown> = Required<TKey>[' $data'];\n\nexport type KeyReturnType<T extends KeyType> = (arg: T) => NonNullable<T[' $data']>;\nexport type ArrayKeyReturnType<T extends ArrayKeyType> = (\n    arg: T,\n) => NonNullable<NonNullable<T[0]>[' $data']>[0];\n\nexport type LoadMoreFn<TQuery extends OperationType = OperationType> = (\n    count: number,\n    options?: OptionsLoadMore<TQuery>,\n) => Disposable;\n\n// pagination\n\nexport const FORWARD = 'forward';\n\nexport type LoadQuery<\n    TOperationType extends OperationType = OperationType,\n    TEnvironment extends IEnvironment = IEnvironment\n> = {\n    next: (\n        environment: TEnvironment,\n        gqlQuery: GraphQLTaggedNode,\n        variables?: TOperationType['variables'],\n        options?: QueryOptions,\n    ) => Promise<void>;\n    subscribe: (callback: () => any) => () => void;\n    getValue: (environment?: TEnvironment) => RenderProps<TOperationType> | Promise<any>;\n    dispose: () => void;\n};\n\n// refetchable\n\nexport interface Options {\n    fetchPolicy?: FetchPolicy;\n    onComplete?: (arg: Error | null) => void;\n    UNSTABLE_renderPolicy?: RenderPolicy;\n}\n\nexport interface OptionsLoadMore<TQuery extends OperationType = OperationType> {\n    //fetchPolicy?: FetchPolicy;\n    onComplete?: (arg: Error | null) => void;\n    UNSTABLE_extraVariables?: VariablesOf<TQuery>;\n}\n\n// NOTE: RefetchFnDynamic returns a refetch function that:\n//  - Expects the /exact/ set of query variables if the provided key type is\n//    /nullable/.\n//  - Or, expects /a subset/ of the query variables if the provided key type is\n//    /non-null/.\nexport type RefetchFnDynamic<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TOptions = Options\n> = RefetchInexactDynamicResponse<TQuery, TOptions> & RefetchExactDynamicResponse<TQuery, TOptions>;\n\nexport type RefetchInexact<TQuery extends OperationType, TOptions> = (\n    data?: unknown,\n) => RefetchFnInexact<TQuery, TOptions>;\nexport type RefetchInexactDynamicResponse<TQuery extends OperationType, TOptions> = ReturnType<\n    RefetchInexact<TQuery, TOptions>\n>;\n\nexport type RefetchExact<TQuery extends OperationType, TOptions> = (\n    data?: unknown | null,\n) => RefetchFnExact<TQuery, TOptions>;\nexport type RefetchExactDynamicResponse<TQuery extends OperationType, TOptions> = ReturnType<\n    RefetchExact<TQuery, TOptions>\n>;\n\nexport type RefetchFnBase<TVars, TOptions> = (vars: TVars, options?: TOptions) => Disposable;\n\nexport type RefetchFnExact<TQuery extends OperationType, TOptions = Options> = RefetchFnBase<\n    VariablesOf<TQuery>,\n    TOptions\n>;\nexport type RefetchFnInexact<TQuery extends OperationType, TOptions = Options> = RefetchFnBase<\n    Partial<VariablesOf<TQuery>>,\n    TOptions\n>;\n\nexport interface ReturnTypeRefetchNode<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> extends ReturnTypeRefetchSuspenseNode<TQuery, TKey, TFragmentData> {\n    isLoading: boolean;\n    error: Error | null;\n}\n\nexport type ReturnTypeRefetchSuspenseNode<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> = { data: TFragmentData; refetch: RefetchFnDynamic<TQuery, TKey> };\n\n// pagination\n\nexport interface ReturnTypePagination<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> extends ReturnTypePaginationSuspense<TQuery, TKey, TFragmentData> {\n    isLoading: boolean;\n    error: Error | null;\n}\n\nexport interface ReturnTypePaginationSuspense<\n    TQuery extends OperationType,\n    TKey extends KeyType | null,\n    TFragmentData\n> {\n    data: TFragmentData;\n    loadNext: LoadMoreFn<TQuery>;\n    loadPrevious: LoadMoreFn<TQuery>;\n    hasNext: boolean;\n    hasPrevious: boolean;\n    isLoadingNext: boolean;\n    isLoadingPrevious: boolean;\n    errorNext: Error | null;\n    errorPrevious: Error | null;\n    refetch: RefetchFnDynamic<TQuery, TKey>;\n}\n\nexport type SubscriptionConfig = {\n    skip?: boolean;\n};\n\nexport type SkipSubscriptionConfig = {\n    skip: true;\n};\n\nexport interface SkipGraphQLSubscriptionConfig<TSubscription extends OperationType>\n    extends Omit<GraphQLSubscriptionConfig<TSubscription>, 'variables' | 'subscription'> {\n    subscription?: GraphQLSubscriptionConfig<TSubscription>['subscription'];\n    variables?: TSubscription['variables'];\n}\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport {\n    Disposable,\n    CacheConfig,\n    IEnvironment,\n    Snapshot,\n    OperationType,\n    OperationDescriptor,\n    GraphQLTaggedNode,\n    Variables,\n} from 'relay-runtime';\nimport { Fetcher, fetchResolver } from './FetchResolver';\nimport { FetchPolicy, RenderProps, QueryOptions, Options } from './RelayHooksTypes';\nimport { createOperation } from './Utils';\n\nconst defaultPolicy = 'network-only';\n\nconst cache: Map<string, QueryFetcher<any>> = new Map();\n\nexport function getOrCreateQueryFetcher<TOperationType extends OperationType>(\n    useLazy: boolean,\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'],\n    networkCacheConfig: CacheConfig,\n): QueryFetcher<TOperationType> {\n    const query = createOperation(gqlQuery, variables, networkCacheConfig);\n    const toGet = useLazy && cache.has(query.request.identifier);\n    const queryFetcher = toGet ? cache.get(query.request.identifier) : new QueryFetcher();\n    queryFetcher.setQuery(gqlQuery, variables, networkCacheConfig, query);\n    return queryFetcher;\n}\n\nconst emptyforceUpdate = (): void => undefined;\n\nexport class QueryFetcher<TOperationType extends OperationType = OperationType> {\n    environment: IEnvironment;\n    query: OperationDescriptor;\n    fetcher: Fetcher;\n    rootSubscription: Disposable;\n    snapshot: Snapshot;\n    fetchPolicy: FetchPolicy;\n    fetchKey: string | number;\n    variables: Variables;\n    cacheConfig: Variables;\n    gqlQuery: GraphQLTaggedNode;\n    options: QueryOptions;\n    forceUpdate = emptyforceUpdate;\n    result: RenderProps<TOperationType> = null;\n    skip?: boolean;\n\n    constructor() {\n        this.result = {\n            retry: this.retry,\n            error: null,\n            data: null,\n            isLoading: false,\n        };\n        this.fetcher = fetchResolver({\n            disposeTemporary: () => {\n                this.dispose();\n                this.query && cache.delete(this.query.request.identifier);\n            },\n        });\n    }\n\n    setQuery(\n        gqlQuery: GraphQLTaggedNode,\n        variables: TOperationType['variables'],\n        networkCacheConfig: CacheConfig,\n        query: OperationDescriptor,\n    ): void {\n        this.gqlQuery = gqlQuery;\n        this.variables = variables;\n        this.query = query;\n        this.cacheConfig = networkCacheConfig;\n    }\n\n    getForceUpdate(): () => void {\n        return this.forceUpdate;\n    }\n\n    setForceUpdate(forceUpdate): void {\n        this.forceUpdate = forceUpdate;\n    }\n\n    dispose(): void {\n        this.fetcher.dispose();\n        this.disposeSnapshot();\n    }\n\n    disposeSnapshot(): void {\n        this.snapshot = null;\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n            this.rootSubscription = null;\n        }\n    }\n\n    retry = (cacheConfigOverride?: CacheConfig | null, options: Options = {}): void => {\n        const { fetchPolicy = 'network-only' } = options;\n        /* eslint-disable indent */\n        const query = cacheConfigOverride\n            ? createOperation(\n                  this.query.request.node,\n                  this.query.request.variables,\n                  cacheConfigOverride,\n              )\n            : this.query;\n        this.fetch(query, fetchPolicy, options);\n        this.resolveResult();\n        this.forceUpdate();\n    };\n\n    fetch(\n        query: OperationDescriptor,\n        fetchPolicy: FetchPolicy,\n        options: Options,\n        skip?: boolean,\n    ): void {\n        this.disposeSnapshot();\n        if (skip) {\n            this.fetcher.dispose();\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        const { onComplete } = options;\n        let fetchHasReturned = false;\n        const onNext = (_o: OperationDescriptor, snapshot: Snapshot): void => {\n            if (!this.snapshot) {\n                this.snapshot = snapshot;\n                this.subscribe(snapshot);\n                this.resolveResult();\n                if (fetchHasReturned) {\n                    this.forceUpdate();\n                }\n            }\n        };\n        const complete = (error: Error | null): void => {\n            this.resolveResult();\n            if (fetchHasReturned) {\n                this.forceUpdate();\n            }\n            onComplete && onComplete(error);\n        };\n        this.fetcher.fetch(this.environment, query, fetchPolicy, complete, onNext);\n        fetchHasReturned = true;\n    }\n\n    getQuery(gqlQuery, variables, networkCacheConfig): OperationDescriptor | null {\n        if (\n            gqlQuery != this.gqlQuery ||\n            networkCacheConfig != this.cacheConfig ||\n            variables != this.variables ||\n            !areEqual(variables, this.variables)\n        ) {\n            this.variables = variables;\n            this.gqlQuery = gqlQuery;\n            this.cacheConfig = networkCacheConfig;\n            return createOperation(gqlQuery, variables, networkCacheConfig);\n        }\n        return this.query;\n    }\n\n    resolveEnvironment(environment: IEnvironment): void {\n        this.resolve(environment, this.gqlQuery, this.variables, this.options);\n    }\n\n    resolve(\n        environment: IEnvironment,\n        gqlQuery: GraphQLTaggedNode,\n        variables: Variables,\n        options: QueryOptions,\n    ): void {\n        const query = this.getQuery(gqlQuery, variables, options.networkCacheConfig);\n        const { fetchPolicy = defaultPolicy, fetchKey, skip } = options;\n        this.options = options;\n        const diffQuery = !this.query || query.request.identifier !== this.query.request.identifier;\n        if (\n            diffQuery ||\n            environment !== this.environment ||\n            fetchPolicy !== this.fetchPolicy ||\n            fetchKey !== this.fetchKey ||\n            skip !== this.skip\n        ) {\n            this.environment = environment;\n            this.query = query;\n            this.skip = skip;\n            this.fetchPolicy = fetchPolicy;\n            this.fetchKey = fetchKey;\n            this.fetch(query, fetchPolicy, options, skip);\n            this.resolveResult();\n        }\n    }\n\n    checkAndSuspense(suspense?: boolean, useLazy?: boolean): Promise<any> | Error | null {\n        if (useLazy) {\n            this.setForceUpdate(emptyforceUpdate);\n            cache.set(this.query.request.identifier, this);\n        }\n        const result = this.fetcher.checkAndSuspense(suspense, useLazy);\n        if (useLazy) {\n            cache.delete(this.query.request.identifier);\n        }\n        return result;\n    }\n\n    getData(): RenderProps<TOperationType> {\n        return this.result;\n    }\n\n    resolveResult(): void {\n        const { error, isLoading } = this.fetcher.getData();\n        this.result = {\n            retry: this.retry,\n            error,\n            data: this.snapshot ? this.snapshot.data : null,\n            isLoading,\n        };\n    }\n\n    subscribe(snapshot): void {\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n        }\n        this.rootSubscription = this.environment.subscribe(snapshot, (snapshot) => {\n            // Read from this._fetchOptions in case onDataChange() was lazily added.\n            this.snapshot = snapshot;\n            //this.error = null;\n\n            this.resolveResult();\n            this.forceUpdate();\n        });\n    }\n}\n","import { Reducer, useReducer } from 'react';\n\nexport function useForceUpdate(): () => void {\n    const [, forceUpdate] = useReducer<Reducer<number, void>>((x) => x + 1, 0);\n    return forceUpdate as () => void;\n}\n","import * as React from 'react';\nimport { IEnvironment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext';\n\nexport function useRelayEnvironment<\n    TEnvironment extends IEnvironment = IEnvironment\n>(): TEnvironment {\n    const { environment } = React.useContext(ReactRelayContext);\n    return environment;\n}\n","import { useRef, useEffect } from 'react';\nimport { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport { getOrCreateQueryFetcher, QueryFetcher } from './QueryFetcher';\nimport { RenderProps, QueryOptions } from './RelayHooksTypes';\nimport { useForceUpdate } from './useForceUpdate';\nimport { useRelayEnvironment } from './useRelayEnvironment';\nimport { forceCache } from './Utils';\n\ntype Reference<TOperationType extends OperationType = OperationType> = {\n    queryFetcher: QueryFetcher<TOperationType>;\n};\n\nconst useInternalQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'],\n    options: QueryOptions,\n    suspense: boolean,\n): RenderProps<TOperationType> => {\n    const environment = useRelayEnvironment();\n    const forceUpdate = useForceUpdate();\n    const ref = useRef<Reference<TOperationType>>();\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            queryFetcher: getOrCreateQueryFetcher(\n                suspense,\n                gqlQuery,\n                variables,\n                options.networkCacheConfig,\n            ),\n        };\n    }\n\n    useEffect(() => {\n        return (): void => ref.current.queryFetcher.dispose();\n    }, []);\n\n    const { queryFetcher } = ref.current;\n    queryFetcher.resolve(environment, gqlQuery, variables, options);\n    queryFetcher.checkAndSuspense(suspense, suspense);\n    queryFetcher.setForceUpdate(forceUpdate);\n    return queryFetcher.getData();\n};\n\nexport const useQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    return useInternalQuery(gqlQuery, variables, options, false);\n};\n\nexport const useLazyLoadQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    options.networkCacheConfig = options.networkCacheConfig ?? forceCache;\n    return useInternalQuery(gqlQuery, variables, options, true);\n};\n","import { GraphQLTaggedNode, OperationType, IEnvironment } from 'relay-runtime';\nimport { QueryFetcher } from './QueryFetcher';\nimport { RenderProps, QueryOptions, LoadQuery } from './RelayHooksTypes';\nimport { forceCache } from './Utils';\n\nconst emptyFunction = (): void => undefined;\n\nexport const internalLoadQuery = <TOperationType extends OperationType = OperationType>(\n    promise = false,\n): LoadQuery<TOperationType> => {\n    let queryFetcher = new QueryFetcher<TOperationType>();\n\n    const dispose = (): void => {\n        queryFetcher.dispose();\n        queryFetcher.setForceUpdate(emptyFunction);\n        queryFetcher = new QueryFetcher<TOperationType>();\n    };\n\n    const next = (\n        environment,\n        gqlQuery: GraphQLTaggedNode,\n        variables: TOperationType['variables'] = {},\n        options: QueryOptions = {},\n    ): Promise<void> => {\n        options.networkCacheConfig = options.networkCacheConfig ?? forceCache;\n        queryFetcher.resolve(environment, gqlQuery, variables, options);\n        const toThrow = queryFetcher.checkAndSuspense();\n        return toThrow\n            ? toThrow instanceof Error\n                ? Promise.reject(toThrow)\n                : toThrow\n            : Promise.resolve();\n    };\n\n    const getValue = (\n        environment?: IEnvironment,\n    ): RenderProps<TOperationType> | null | Promise<any> => {\n        queryFetcher.resolveEnvironment(environment);\n        queryFetcher.checkAndSuspense(promise);\n        return queryFetcher.getData();\n    };\n\n    const subscribe = (callback: () => any): (() => void) => {\n        queryFetcher.setForceUpdate(callback);\n        return (): void => {\n            if (queryFetcher.getForceUpdate() === callback) {\n                queryFetcher.setForceUpdate(emptyFunction);\n            }\n        };\n    };\n    return {\n        next,\n        subscribe,\n        getValue,\n        dispose,\n    };\n};\n\nexport const loadLazyQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(true);\n};\n\nexport const loadQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(false);\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import * as invariant from 'fbjs/lib/invariant';\n\nexport function getValueAtPath(data: any, path: ReadonlyArray<string | number>): any {\n    let result = data;\n    for (const key of path) {\n        if (result == null) {\n            return null;\n        }\n        if (typeof key === 'number') {\n            invariant(\n                Array.isArray(result),\n                'Relay: Expected an array when extracting value at path. ' +\n                    \"If you're seeing this, this is likely a bug in Relay.\",\n            );\n            result = result[key];\n        } else {\n            invariant(\n                typeof result === 'object' && !Array.isArray(result),\n                'Relay: Expected an object when extracting value at path. ' +\n                    \"If you're seeing this, this is likely a bug in Relay.\",\n            );\n            result = result[key];\n        }\n    }\n    return result;\n}\n","import * as invariant from 'fbjs/lib/invariant';\nimport { ConnectionInterface, ReaderFragment } from 'relay-runtime';\nimport { getValueAtPath } from './getValueAtPath';\n\nexport function getStateFromConnection(\n    direction: string,\n    fragmentNode: ReaderFragment,\n    connection: any | null,\n): {\n    cursor: string | null;\n    hasMore: boolean;\n} {\n    if (connection == null) {\n        return { cursor: null, hasMore: false };\n    }\n    const {\n        EDGES,\n        PAGE_INFO,\n        HAS_NEXT_PAGE,\n        HAS_PREV_PAGE,\n        END_CURSOR,\n        START_CURSOR,\n    } = ConnectionInterface.get();\n\n    invariant(\n        typeof connection === 'object',\n        'Relay: Expected connection in fragment `%s` to have been `null`, or ' +\n            'a plain object with %s and %s properties. Instead got `%s`.',\n        fragmentNode.name,\n        EDGES,\n        PAGE_INFO,\n        connection,\n    );\n\n    const edges = connection[EDGES];\n    const pageInfo = connection[PAGE_INFO];\n    if (edges == null || pageInfo == null) {\n        return { cursor: null, hasMore: false };\n    }\n\n    invariant(\n        Array.isArray(edges),\n        'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' +\n            'Instead got `%s`.',\n        fragmentNode.name,\n        EDGES,\n        edges,\n    );\n    invariant(\n        typeof pageInfo === 'object',\n        'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.',\n        fragmentNode.name,\n        PAGE_INFO,\n        pageInfo,\n    );\n\n    const cursor =\n        direction === 'forward' ? pageInfo[END_CURSOR] ?? null : pageInfo[START_CURSOR] ?? null;\n    invariant(\n        cursor === null || typeof cursor === 'string',\n        'Relay: Expected page info for connection in fragment `%s` to have a ' +\n            'valid `%s`. Instead got `%s`.',\n        fragmentNode.name,\n        START_CURSOR,\n        cursor,\n    );\n\n    let hasMore;\n    if (direction === 'forward') {\n        hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;\n    } else {\n        hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;\n    }\n\n    return { cursor, hasMore };\n}\n\nexport function getConnectionState(\n    direction: string,\n    fragmentNode: ReaderFragment,\n    fragmentData: any,\n    connectionPathInFragmentData: ReadonlyArray<string | number>,\n): {\n    cursor: string | null;\n    hasMore: boolean;\n} {\n    const connection = getValueAtPath(fragmentData, connectionPathInFragmentData);\n    return getStateFromConnection(direction, fragmentNode, connection);\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * @flow strict-local\n * @format\n */\n\n// flowlint ambiguous-object-type:error\n\n'use strict';\n\nimport * as invariant from 'fbjs/lib/invariant';\n\nimport { ConcreteRequest, ReaderFragment, ReaderRefetchMetadata } from 'relay-runtime';\n\nexport function getRefetchMetadata(\n    fragmentNode: ReaderFragment,\n    componentDisplayName: string,\n): {\n    fragmentRefPathInResponse: ReadonlyArray<string | number>;\n    identifierField: string | null;\n    refetchableRequest: ConcreteRequest;\n    refetchMetadata: ReaderRefetchMetadata;\n} {\n    invariant(\n        fragmentNode.metadata?.plural !== true,\n        'Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using ' +\n            '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' +\n            'in order to use it with `%s`.',\n        fragmentNode.name,\n        componentDisplayName,\n        fragmentNode.name,\n        componentDisplayName,\n    );\n\n    const refetchMetadata = fragmentNode.metadata?.refetch;\n    invariant(\n        refetchMetadata != null,\n        'Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. ' +\n            'Did you forget to add a @refetchable directive to the fragment?',\n        componentDisplayName,\n        fragmentNode.name,\n    );\n\n    // handle both commonjs and es modules\n    const refetchableRequest: ConcreteRequest = (refetchMetadata as any).operation.default\n        ? (refetchMetadata as any).operation.default\n        : refetchMetadata.operation;\n    const fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;\n    invariant(\n        typeof refetchableRequest !== 'string',\n        'Relay: getRefetchMetadata(): Expected refetch query to be an ' +\n            \"operation and not a string when using `%s`. If you're seeing this, \" +\n            'this is likely a bug in Relay.',\n        componentDisplayName,\n    );\n    const identifierField = refetchMetadata.identifierField;\n    invariant(\n        identifierField == null || typeof identifierField === 'string',\n        'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.',\n    );\n    return {\n        fragmentRefPathInResponse,\n        identifierField,\n        refetchableRequest,\n        refetchMetadata,\n    };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * @flow strict-local\n * @format\n */\n\n// flowlint ambiguous-object-type:error\n\n'use strict';\n\nimport * as invariant from 'fbjs/lib/invariant';\n\nimport { ConcreteRequest, ReaderFragment, ReaderPaginationMetadata } from 'relay-runtime';\nimport { getRefetchMetadata } from './getRefetchMetadata';\n\nexport function getPaginationMetadata(\n    fragmentNode: ReaderFragment,\n    componentDisplayName: string,\n): {\n    connectionPathInFragmentData: ReadonlyArray<string | number>;\n    identifierField: string | null;\n    paginationRequest: ConcreteRequest;\n    paginationMetadata: ReaderPaginationMetadata;\n    stream: boolean;\n} {\n    const { refetchableRequest: paginationRequest, refetchMetadata } = getRefetchMetadata(\n        fragmentNode,\n        componentDisplayName,\n    );\n\n    const paginationMetadata = refetchMetadata.connection;\n    invariant(\n        paginationMetadata != null,\n        'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' +\n            'connection when using `%s`. Did you forget to add a @connection ' +\n            'directive to the connection field in the fragment?',\n        componentDisplayName,\n        fragmentNode.name,\n    );\n    const connectionPathInFragmentData = paginationMetadata.path;\n\n    const connectionMetadata = (fragmentNode.metadata?.connection ?? [])[0];\n    invariant(\n        connectionMetadata != null,\n        'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' +\n            'connection when using `%s`. Did you forget to add a @connection ' +\n            'directive to the connection field in the fragment?',\n        componentDisplayName,\n        fragmentNode.name,\n    );\n    const identifierField = refetchMetadata.identifierField;\n    invariant(\n        identifierField == null || typeof identifierField === 'string',\n        'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.',\n    );\n    return {\n        connectionPathInFragmentData,\n        identifierField,\n        paginationRequest,\n        paginationMetadata,\n        stream: connectionMetadata.stream === true,\n    };\n}\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as warning from 'fbjs/lib/warning';\nimport {\n    __internal,\n    getSelector,\n    IEnvironment,\n    Disposable,\n    Snapshot,\n    Variables,\n    getVariablesFromFragment,\n    OperationDescriptor,\n    getFragmentIdentifier,\n    PluralReaderSelector,\n    ReaderSelector,\n    SingularReaderSelector,\n    ReaderFragment,\n    getDataIDsFromFragment,\n    RequestDescriptor,\n} from 'relay-runtime';\nimport { Fetcher, fetchResolver } from './FetchResolver';\nimport { getConnectionState, getStateFromConnection } from './getConnectionState';\nimport { getPaginationMetadata } from './getPaginationMetadata';\nimport { getPaginationVariables } from './getPaginationVariables';\nimport { getRefetchMetadata } from './getRefetchMetadata';\nimport { getValueAtPath } from './getValueAtPath';\nimport {\n    FragmentNames,\n    Options,\n    OptionsLoadMore,\n    PAGINATION_NAME,\n    REFETCHABLE_NAME,\n} from './RelayHooksTypes';\nimport { createOperation, forceCache } from './Utils';\nconst { getPromiseForActiveRequest } = __internal;\n\ntype SingularOrPluralSnapshot = Snapshot | Array<Snapshot>;\n\nfunction lookupFragment(environment, selector): SingularOrPluralSnapshot {\n    return selector.kind === 'PluralReaderSelector'\n        ? selector.selectors.map((s) => environment.lookup(s))\n        : environment.lookup(selector);\n}\n\nfunction getFragmentResult(snapshot: SingularOrPluralSnapshot): any {\n    const missData = isMissingData(snapshot);\n    if (Array.isArray(snapshot)) {\n        return { snapshot, data: snapshot.map((s) => s.data), isMissingData: missData };\n    }\n    return { snapshot, data: snapshot.data, isMissingData: missData };\n}\n\ntype FragmentResult = {\n    snapshot?: SingularOrPluralSnapshot | null;\n    data: any;\n    isMissingData?: boolean;\n    owner?: any;\n};\n\nfunction isMissingData(snapshot: SingularOrPluralSnapshot): boolean {\n    if (Array.isArray(snapshot)) {\n        return snapshot.some((s) => s.isMissingData);\n    }\n    return snapshot.isMissingData;\n}\n\nfunction _getAndSavePromiseForFragmentRequestInFlight(\n    fragmentNode: ReaderFragment,\n    fragmentOwner: RequestDescriptor,\n    env: IEnvironment,\n): Promise<void> | null {\n    let networkPromise = getPromiseForActiveRequest(env, fragmentOwner);\n    let pendingOperationName;\n\n    if (networkPromise != null) {\n        pendingOperationName = fragmentOwner.node.params.name;\n    } else {\n        const result = env.getOperationTracker().getPendingOperationsAffectingOwner(fragmentOwner);\n        const pendingOperations = result?.pendingOperations;\n        networkPromise = result?.promise ?? null;\n        pendingOperationName =\n            pendingOperations?.map((op) => op.node.params.name).join(',') ?? null;\n    }\n\n    if (!networkPromise) {\n        return null;\n    }\n\n    if (pendingOperationName == null || pendingOperationName.length === 0) {\n        pendingOperationName = 'Unknown pending operation';\n    }\n\n    // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n    const fragmentName = fragmentNode.name;\n    const promiseDisplayName =\n        pendingOperationName === fragmentName\n            ? `Relay(${pendingOperationName})`\n            : `Relay(${pendingOperationName}:${fragmentName})`;\n\n    (networkPromise as any).displayName = promiseDisplayName;\n    return networkPromise;\n}\n\nexport class FragmentResolver {\n    _environment: IEnvironment;\n    _fragment: ReaderFragment;\n    _fragmentRef: any;\n    _fragmentRefRefetch: any;\n    _idfragment: any;\n    _idfragmentrefetch: any;\n    resolverData: FragmentResult;\n    _disposable: Disposable;\n    _selector: ReaderSelector;\n    refreshHooks: any;\n    fetcherRefecth: Fetcher;\n    fetcherNext: Fetcher;\n    fetcherPrevious: Fetcher;\n    unmounted = false;\n    name: string;\n    refetchable = false;\n    pagination = false;\n    result: any;\n    _subscribeResolve;\n\n    constructor(name: FragmentNames) {\n        this.name = name;\n        this.pagination = name === PAGINATION_NAME;\n        this.refetchable = name === REFETCHABLE_NAME || this.pagination;\n\n        const setLoading = (_loading): void => this.refreshHooks();\n        if (this.refetchable) {\n            this.fetcherRefecth = fetchResolver({\n                setLoading,\n                doRetain: true,\n            });\n        }\n        if (this.pagination) {\n            this.fetcherNext = fetchResolver({ setLoading });\n            this.fetcherPrevious = fetchResolver({ setLoading });\n        }\n    }\n\n    setForceUpdate(forceUpdate = (): void => undefined): void {\n        this.refreshHooks = (): void => {\n            this.resolveResult();\n            forceUpdate();\n        };\n    }\n\n    subscribeResolve(subscribeResolve: (data: any) => void): void {\n        if (this._subscribeResolve && this._subscribeResolve != subscribeResolve) {\n            subscribeResolve(this.getData());\n        }\n        this._subscribeResolve = subscribeResolve;\n    }\n\n    setUnmounted(): void {\n        this.unmounted = true;\n    }\n\n    isEqualsFragmentRef(prevFragment, fragmentRef): boolean {\n        if (this._fragmentRef !== fragmentRef) {\n            const prevIDs = getDataIDsFromFragment(this._fragment, prevFragment);\n            const nextIDs = getDataIDsFromFragment(this._fragment, fragmentRef);\n            if (\n                !areEqual(prevIDs, nextIDs) ||\n                !areEqual(\n                    this.getFragmentVariables(fragmentRef),\n                    this.getFragmentVariables(prevFragment),\n                )\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    dispose(): void {\n        this.unsubscribe();\n        this.fetcherNext && this.fetcherNext.dispose();\n        this.fetcherPrevious && this.fetcherPrevious.dispose();\n        this._idfragmentrefetch = null;\n        this._fragmentRefRefetch = null;\n        this.fetcherRefecth && this.fetcherRefecth.dispose();\n    }\n\n    getFragmentVariables(fRef = this._fragmentRef): Variables {\n        return getVariablesFromFragment(this._fragment, fRef);\n    }\n\n    resolve(\n        environment: IEnvironment,\n        idfragment: string,\n        fragment: ReaderFragment,\n        fragmentRef,\n    ): void {\n        if (\n            !this.resolverData ||\n            this._environment !== environment ||\n            (idfragment !== this._idfragment &&\n                (!this._idfragmentrefetch ||\n                    (this._idfragmentrefetch && idfragment !== this._idfragmentrefetch)))\n        ) {\n            this._fragment = fragment;\n            this._fragmentRef = fragmentRef;\n            this._idfragment = idfragment;\n            this._selector = null;\n            this.dispose();\n            this._environment = environment;\n            this.lookup(fragment, this._fragmentRef);\n            this.resolveResult();\n        }\n    }\n\n    lookup(fragment, fragmentRef): void {\n        if (fragmentRef == null) {\n            this.resolverData = { data: null };\n            return;\n        }\n        const isPlural =\n            fragment.metadata && fragment.metadata.plural && fragment.metadata.plural === true;\n        if (isPlural) {\n            if (fragmentRef.length === 0) {\n                this.resolverData = { data: [] };\n                return;\n            }\n        }\n        this._selector = getSelector(fragment, fragmentRef);\n        const snapshot = lookupFragment(this._environment, this._selector);\n\n        this.resolverData = getFragmentResult(snapshot);\n        const owner = this._selector\n            ? this._selector.kind === 'PluralReaderSelector'\n                ? (this._selector as any).selectors[0].owner\n                : (this._selector as any).owner\n            : null;\n        this.resolverData.owner = owner;\n        //this.subscribe();\n    }\n\n    checkAndSuspense(suspense): void {\n        if (suspense && this.resolverData.isMissingData && this.resolverData.owner) {\n            const fragmentOwner = this.resolverData.owner;\n            const networkPromise = _getAndSavePromiseForFragmentRequestInFlight(\n                this._fragment,\n                fragmentOwner,\n                this._environment,\n            );\n            const parentQueryName = fragmentOwner.node.params.name ?? 'Unknown Parent Query';\n            if (networkPromise != null) {\n                // When the Promise for the request resolves, we need to make sure to\n                // update the cache with the latest data available in the store before\n                // resolving the Promise\n                const promise = networkPromise\n                    .then(() => {\n                        if (this._idfragmentrefetch) {\n                            this.resolveResult();\n                        } else {\n                            this._idfragment = null;\n                            this.dispose();\n                        }\n                        //;\n                    })\n                    .catch((_error: Error) => {\n                        if (this._idfragmentrefetch) {\n                            this.resolveResult();\n                        } else {\n                            this._idfragment = null;\n                            this.dispose();\n                        }\n                    });\n\n                // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n                (promise as any).displayName = 'Relay(' + parentQueryName + ')';\n                this.unsubscribe();\n                this.refreshHooks = (): void => undefined;\n                throw promise;\n            }\n            warning(\n                false,\n                'Relay: Tried reading fragment `%s` declared in ' +\n                    '`%s`, but it has missing data and its parent query `%s` is not ' +\n                    'being fetched.\\n' +\n                    'This might be fixed by by re-running the Relay Compiler. ' +\n                    ' Otherwise, make sure of the following:\\n' +\n                    '* You are correctly fetching `%s` if you are using a ' +\n                    '\"store-only\" `fetchPolicy`.\\n' +\n                    \"* Other queries aren't accidentally fetching and overwriting \" +\n                    'the data for this fragment.\\n' +\n                    '* Any related mutations or subscriptions are fetching all of ' +\n                    'the data for this fragment.\\n' +\n                    \"* Any related store updaters aren't accidentally deleting \" +\n                    'data for this fragment.',\n                this._fragment.name,\n                this.name,\n                parentQueryName,\n                parentQueryName,\n            );\n        }\n        this.fetcherRefecth && this.fetcherRefecth.checkAndSuspense(suspense);\n    }\n\n    getData(): any | null {\n        return this.result;\n    }\n\n    resolveResult(): any {\n        const { data } = this.resolverData;\n        if (this.refetchable || this.pagination) {\n            const { isLoading, error } = this.fetcherRefecth.getData();\n            const refetch = this.refetch;\n            if (!this.pagination) {\n                // useRefetchable\n                if ('production' !== process.env.NODE_ENV) {\n                    getRefetchMetadata(this._fragment, this.name);\n                }\n                this.result = {\n                    data,\n                    isLoading,\n                    error,\n                    refetch,\n                };\n            } else {\n                // usePagination\n                const { connectionPathInFragmentData } = getPaginationMetadata(\n                    this._fragment,\n                    this.name,\n                );\n\n                const connection = getValueAtPath(data, connectionPathInFragmentData);\n                const { hasMore: hasNext } = getStateFromConnection(\n                    'forward',\n                    this._fragment,\n                    connection,\n                );\n                const { hasMore: hasPrevious } = getStateFromConnection(\n                    'backward',\n                    this._fragment,\n                    connection,\n                );\n                const { isLoading: isLoadingNext, error: errorNext } = this.fetcherNext.getData();\n                const {\n                    isLoading: isLoadingPrevious,\n                    error: errorPrevious,\n                } = this.fetcherPrevious.getData();\n                this.result = {\n                    data,\n                    hasNext,\n                    isLoadingNext,\n                    hasPrevious,\n                    isLoadingPrevious,\n                    isLoading,\n                    errorNext,\n                    errorPrevious,\n                    error,\n                    refetch,\n                    loadNext: this.loadNext,\n                    loadPrevious: this.loadPrevious,\n                };\n            }\n        } else {\n            // useFragment\n            this.result = data;\n        }\n        this._subscribeResolve && this._subscribeResolve(this.result);\n    }\n\n    unsubscribe(): void {\n        this._disposable && this._disposable.dispose();\n    }\n\n    subscribe(): void {\n        const environment = this._environment;\n        const renderedSnapshot = this.resolverData.snapshot;\n        this.unsubscribe();\n        const dataSubscriptions = [];\n        if (renderedSnapshot) {\n            if (Array.isArray(renderedSnapshot)) {\n                renderedSnapshot.forEach((snapshot, idx) => {\n                    dataSubscriptions.push(\n                        environment.subscribe(snapshot, (latestSnapshot) => {\n                            this.resolverData.snapshot[idx] = latestSnapshot;\n                            this.resolverData.data[idx] = latestSnapshot.data;\n                            this.resolverData.isMissingData = false;\n                            this.refreshHooks();\n                        }),\n                    );\n                });\n            } else {\n                dataSubscriptions.push(\n                    environment.subscribe(renderedSnapshot, (latestSnapshot) => {\n                        this.resolverData = getFragmentResult(latestSnapshot);\n                        this.resolverData.isMissingData = false;\n                        this.refreshHooks();\n                    }),\n                );\n            }\n        }\n\n        this._disposable = {\n            dispose: (): void => {\n                dataSubscriptions.map((s) => s.dispose());\n                this._disposable = undefined;\n            },\n        };\n    }\n\n    refetch = (variables: Variables, options?: Options): Disposable => {\n        if (this.unmounted === true) {\n            warning(\n                false,\n                'Relay: Unexpected call to `refetch` on unmounted component for fragment ' +\n                    '`%s` in `%s`. It looks like some instances of your component are ' +\n                    'still trying to fetch data but they already unmounted. ' +\n                    'Please make sure you clear all timers, intervals, ' +\n                    'async calls, etc that may trigger a fetch.',\n                this._fragment.name,\n                this.name,\n            );\n            return { dispose: (): void => {} };\n        }\n        if (this._selector == null) {\n            warning(\n                false,\n                'Relay: Unexpected call to `refetch` while using a null fragment ref ' +\n                    'for fragment `%s` in `%s`. When calling `refetch`, we expect ' +\n                    \"initial fragment data to be non-null. Please make sure you're \" +\n                    'passing a valid fragment ref to `%s` before calling ' +\n                    '`refetch`, or make sure you pass all required variables to `refetch`.',\n                this._fragment.name,\n                this.name,\n                this.name,\n            );\n        }\n\n        const {\n            fragmentRefPathInResponse,\n            identifierField,\n            refetchableRequest,\n        } = getRefetchMetadata(this._fragment, this.name);\n        const fragmentData = this.getData().data;\n        const identifierValue =\n            identifierField != null && fragmentData != null && typeof fragmentData === 'object'\n                ? fragmentData[identifierField]\n                : null;\n\n        let parentVariables;\n        let fragmentVariables;\n        if (this._selector == null) {\n            parentVariables = {};\n            fragmentVariables = {};\n        } else if (this._selector.kind === 'PluralReaderSelector') {\n            parentVariables =\n                (this._selector as PluralReaderSelector).selectors[0]?.owner.variables ?? {};\n            fragmentVariables =\n                (this._selector as PluralReaderSelector).selectors[0]?.variables ?? {};\n        } else {\n            parentVariables = (this._selector as SingularReaderSelector).owner.variables;\n            fragmentVariables = (this._selector as SingularReaderSelector).variables;\n        }\n\n        // NOTE: A user of `useRefetchableFragment()` may pass a subset of\n        // all variables required by the fragment when calling `refetch()`.\n        // We fill in any variables not passed by the call to `refetch()` with the\n        // variables from the original parent fragment owner.\n        /* $FlowFixMe[cannot-spread-indexer] (>=0.123.0) This comment suppresses\n         * an error found when Flow v0.123.0 was deployed. To see the error\n         * delete this comment and run Flow. */\n        const refetchVariables = {\n            ...parentVariables,\n            /* $FlowFixMe[exponential-spread] (>=0.111.0) This comment suppresses\n             * an error found when Flow v0.111.0 was deployed. To see the error,\n             * delete this comment and run Flow. */\n            ...fragmentVariables,\n            ...variables,\n        };\n\n        if (identifierField != null && !variables.hasOwnProperty('id')) {\n            // @refetchable fragments are guaranteed to have an `id` selection\n            // if the type is Node, implements Node, or is @fetchable. Double-check\n            // that there actually is a value at runtime.\n            if (typeof identifierValue !== 'string') {\n                warning(\n                    false,\n                    'Relay: Expected result to have a string  ' +\n                        '`%s` in order to refetch, got `%s`.',\n                    identifierField,\n                    identifierValue,\n                );\n            }\n            refetchVariables.id = identifierValue;\n        }\n\n        const onNext = (operation: OperationDescriptor, snapshot: Snapshot): void => {\n            const fragmentRef = getValueAtPath(snapshot.data, fragmentRefPathInResponse);\n            const isEquals = this.isEqualsFragmentRef(\n                this._fragmentRefRefetch || this._fragmentRef,\n                fragmentRef,\n            );\n            const missData = isMissingData(snapshot); //fromStore && isMissingData(snapshot);\n            if (!isEquals || missData) {\n                this._fragmentRefRefetch = fragmentRef;\n                this._idfragmentrefetch = getFragmentIdentifier(this._fragment, fragmentRef);\n                this.lookup(this._fragment, fragmentRef);\n                this.subscribe();\n                /*if (!missData) {\n                    this.subscribe();\n                }*/\n                this.resolverData.isMissingData = missData;\n                this.resolverData.owner = operation.request;\n                this.refreshHooks();\n            }\n        };\n        if (this.pagination) {\n            this.fetcherNext.dispose();\n            this.fetcherPrevious.dispose();\n        }\n        const operation = createOperation(refetchableRequest, refetchVariables, forceCache);\n        return this.fetcherRefecth.fetch(\n            this._environment,\n            operation,\n            options?.fetchPolicy,\n            options?.onComplete,\n            onNext,\n            options?.UNSTABLE_renderPolicy,\n        );\n    };\n\n    loadPrevious = (count: number, options?: OptionsLoadMore): Disposable => {\n        return this.loadMore('backward', count, options);\n    };\n\n    loadNext = (count: number, options?: OptionsLoadMore): Disposable => {\n        return this.loadMore('forward', count, options);\n    };\n\n    loadMore = (\n        direction: 'backward' | 'forward',\n        count: number,\n        options?: OptionsLoadMore,\n    ): Disposable => {\n        const onComplete = options?.onComplete ?? ((): void => undefined);\n\n        const fragmentData = this.getData().data;\n\n        const fetcher = direction === 'backward' ? this.fetcherPrevious : this.fetcherNext;\n        if (this.unmounted === true) {\n            // Bail out and warn if we're trying to paginate after the component\n            // has unmounted\n            warning(\n                false,\n                'Relay: Unexpected fetch on unmounted component for fragment ' +\n                    '`%s` in `%s`. It looks like some instances of your component are ' +\n                    'still trying to fetch data but they already unmounted. ' +\n                    'Please make sure you clear all timers, intervals, ' +\n                    'async calls, etc that may trigger a fetch.',\n                this._fragment.name,\n                this.name,\n            );\n            return { dispose: (): void => {} };\n        }\n        if (this._selector == null) {\n            warning(\n                false,\n                'Relay: Unexpected fetch while using a null fragment ref ' +\n                    'for fragment `%s` in `%s`. When fetching more items, we expect ' +\n                    \"initial fragment data to be non-null. Please make sure you're \" +\n                    'passing a valid fragment ref to `%s` before paginating.',\n                this._fragment.name,\n                this.name,\n                this.name,\n            );\n            onComplete(null);\n            return { dispose: (): void => {} };\n        }\n        const isRequestActive = (this._environment as any).isRequestActive(\n            (this._selector as SingularReaderSelector).owner.identifier,\n        );\n        if (isRequestActive || fetcher.getData().isLoading === true || fragmentData == null) {\n            onComplete(null);\n            return { dispose: (): void => {} };\n        }\n        invariant(\n            this._selector != null && this._selector.kind !== 'PluralReaderSelector',\n            'Relay: Expected to be able to find a non-plural fragment owner for ' +\n                \"fragment `%s` when using `%s`. If you're seeing this, \" +\n                'this is likely a bug in Relay.',\n            this._fragment.name,\n            this.name,\n        );\n\n        const {\n            paginationRequest,\n            paginationMetadata,\n            identifierField,\n            connectionPathInFragmentData,\n        } = getPaginationMetadata(this._fragment, this.name);\n        const identifierValue =\n            identifierField != null && fragmentData != null && typeof fragmentData === 'object'\n                ? fragmentData[identifierField]\n                : null;\n\n        const parentVariables = (this._selector as SingularReaderSelector).owner.variables;\n        const fragmentVariables = (this._selector as SingularReaderSelector).variables;\n        const extraVariables = options?.UNSTABLE_extraVariables;\n        const baseVariables = {\n            ...parentVariables,\n            ...fragmentVariables,\n        };\n        const { cursor } = getConnectionState(\n            direction,\n            this._fragment,\n            fragmentData,\n            connectionPathInFragmentData,\n        );\n        const paginationVariables = getPaginationVariables(\n            direction,\n            count,\n            cursor,\n            baseVariables,\n            { ...extraVariables },\n            paginationMetadata,\n        );\n\n        // If the query needs an identifier value ('id' or similar) and one\n        // was not explicitly provided, read it from the fragment data.\n        if (identifierField != null) {\n            // @refetchable fragments are guaranteed to have an `id` selection\n            // if the type is Node, implements Node, or is @fetchable. Double-check\n            // that there actually is a value at runtime.\n            if (typeof identifierValue !== 'string') {\n                warning(\n                    false,\n                    'Relay: Expected result to have a string  ' +\n                        '`%s` in order to refetch, got `%s`.',\n                    identifierField,\n                    identifierValue,\n                );\n            }\n            paginationVariables.id = identifierValue;\n        }\n\n        const onNext = (): void => {};\n\n        const operation = createOperation(paginationRequest, paginationVariables, forceCache);\n        return fetcher.fetch(\n            this._environment,\n            operation,\n            undefined, //options?.fetchPolicy,\n            onComplete,\n            onNext,\n        );\n    };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * @flow strict-local\n * @format\n */\n\n// flowlint ambiguous-object-type:error\n\n'use strict';\n\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as warning from 'fbjs/lib/warning';\n\nimport { ReaderPaginationMetadata, Variables } from 'relay-runtime';\n\nexport function getPaginationVariables(\n    direction: 'forward' | 'backward',\n    count: number,\n    cursor: string | null,\n    baseVariables: Variables,\n    extraVariables: Variables,\n    paginationMetadata: ReaderPaginationMetadata,\n): { [key: string]: any } {\n    const { backward: backwardMetadata, forward: forwardMetadata } = paginationMetadata;\n\n    if (direction === 'backward') {\n        invariant(\n            backwardMetadata != null &&\n                backwardMetadata.count != null &&\n                backwardMetadata.cursor != null,\n            'Relay: Expected backward pagination metadata to be available. ' +\n                \"If you're seeing this, this is likely a bug in Relay.\",\n        );\n        warning(\n            !extraVariables.hasOwnProperty(backwardMetadata.cursor),\n            'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n                'contain cursor variable `%s`. This variable is automatically ' +\n                'determined by Relay.',\n            backwardMetadata.cursor,\n        );\n        warning(\n            !extraVariables.hasOwnProperty(backwardMetadata.count),\n            'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n                'contain count variable `%s`. This variable is automatically ' +\n                'determined by Relay.',\n            backwardMetadata.count,\n        );\n        const paginationVariables = {\n            ...baseVariables,\n            ...extraVariables,\n            [backwardMetadata.cursor]: cursor,\n            [backwardMetadata.count]: count,\n        };\n        if (forwardMetadata && forwardMetadata.cursor) {\n            paginationVariables[forwardMetadata.cursor] = null;\n        }\n        if (forwardMetadata && forwardMetadata.count) {\n            paginationVariables[forwardMetadata.count] = null;\n        }\n        return paginationVariables;\n    }\n\n    invariant(\n        forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null,\n        'Relay: Expected forward pagination metadata to be available. ' +\n            \"If you're seeing this, this is likely a bug in Relay.\",\n    );\n    warning(\n        !extraVariables.hasOwnProperty(forwardMetadata.cursor),\n        'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n            'contain cursor variable `%s`. This variable is automatically ' +\n            'determined by Relay.',\n        forwardMetadata.cursor,\n    );\n    warning(\n        !extraVariables.hasOwnProperty(forwardMetadata.count),\n        'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\n            'contain count variable `%s`. This variable is automatically ' +\n            'determined by Relay.',\n        forwardMetadata.count,\n    );\n    const paginationVariables = {\n        ...baseVariables,\n        ...extraVariables,\n        [forwardMetadata.cursor]: cursor,\n        [forwardMetadata.count]: count,\n    };\n    if (backwardMetadata && backwardMetadata.cursor) {\n        paginationVariables[backwardMetadata.cursor] = null;\n    }\n    if (backwardMetadata && backwardMetadata.count) {\n        paginationVariables[backwardMetadata.count] = null;\n    }\n    return paginationVariables;\n}\n","import * as warning from 'fbjs/lib/warning';\nimport { useEffect, useRef, useMemo } from 'react';\nimport { GraphQLTaggedNode, getFragmentIdentifier, getFragment } from 'relay-runtime';\nimport { FragmentResolver } from './FragmentResolver';\nimport { FragmentNames } from './RelayHooksTypes';\nimport { useForceUpdate } from './useForceUpdate';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useOssFragment(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: any | null,\n    suspense: boolean,\n    name: FragmentNames,\n    subscribeResolve?: (data: any) => void,\n): any {\n    const environment = useRelayEnvironment();\n    const forceUpdate = useForceUpdate();\n    const ref = useRef<{ resolver: FragmentResolver }>(null);\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            resolver: new FragmentResolver(name),\n        };\n    }\n\n    const { resolver } = ref.current;\n\n    useEffect(() => {\n        return (): void => {\n            ref.current.resolver.setUnmounted();\n        };\n    }, []);\n\n    useEffect(() => {\n        return (): void => {\n            resolver.dispose();\n        };\n    }, [resolver]);\n\n    const fragment = useMemo(() => {\n        return getFragment(fragmentNode);\n    }, [fragmentNode]);\n\n    const idfragment = useMemo(() => {\n        return getFragmentIdentifier(fragment, fragmentRef);\n    }, [fragment, fragmentRef]);\n\n    useEffect(() => {\n        resolver.subscribe();\n        return (): void => {\n            resolver.unsubscribe();\n        };\n    }, [resolver, idfragment, environment]);\n\n    resolver.subscribeResolve(subscribeResolve);\n\n    resolver.resolve(environment, idfragment, fragment, fragmentRef);\n    if (subscribeResolve) {\n        resolver.setForceUpdate();\n        return;\n    }\n\n    resolver.checkAndSuspense(suspense);\n    resolver.setForceUpdate(forceUpdate);\n\n    const data = resolver.getData();\n\n    if ('production' !== process.env.NODE_ENV) {\n        if (\n            fragmentRef != null &&\n            (data === undefined ||\n                (Array.isArray(data) &&\n                    data.length > 0 &&\n                    data.every((data) => data === undefined)))\n        ) {\n            warning(\n                false,\n                'Relay: Expected to have been able to read non-null data for ' +\n                    'fragment `%s` declared in ' +\n                    '`%s`, since fragment reference was non-null. ' +\n                    \"Make sure that that `%s`'s parent isn't \" +\n                    'holding on to and/or passing a fragment reference for data that ' +\n                    'has been deleted.',\n                fragment,\n                name,\n                name,\n            );\n        }\n    }\n\n    return [data, resolver];\n}\n","import useMounted from '@restart/hooks/useMounted';\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as React from 'react';\nimport { Environment, MutationParameters, commitMutation } from 'relay-runtime';\nimport {\n    MutationNode,\n    MutationConfig,\n    MutationConfigWithoutVariables,\n    MutationState,\n    Mutate,\n    MutateWithVariables,\n} from './RelayHooksTypes';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nconst { useCallback, useState } = React;\n\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig?: MutationConfigWithoutVariables<T>,\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [MutateWithVariables<T>, MutationState<T>];\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig?: MutationConfig<T>,\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [Mutate<T>, MutationState<T>];\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig: MutationConfig<T> = {},\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [Mutate<T>, MutationState<T>] {\n    const [state, setState] = useState<MutationState<T>>({\n        loading: false,\n        data: null,\n        error: null,\n    });\n\n    const isMounted = useMounted();\n\n    const relayEnvironment = useRelayEnvironment();\n    const resolvedEnvironment = environment || relayEnvironment;\n    const {\n        configs,\n        variables,\n        uploadables,\n        onCompleted,\n        onError,\n        optimisticUpdater,\n        optimisticResponse,\n        updater,\n    } = userConfig;\n\n    const mutate: Mutate<T> = useCallback(\n        (config) => {\n            const mergedConfig = {\n                configs,\n                variables,\n                uploadables,\n                onCompleted,\n                onError,\n                optimisticUpdater,\n                optimisticResponse,\n                updater,\n                ...config,\n            };\n\n            invariant(mergedConfig.variables, 'you must specify variables');\n\n            if (isMounted()) {\n                setState({\n                    loading: true,\n                    data: mergedConfig.optimisticResponse,\n                    error: null,\n                });\n            }\n\n            return new Promise((resolve, reject) => {\n                function handleError(error: any): void {\n                    if (isMounted()) {\n                        setState({\n                            loading: false,\n                            data: null,\n                            error,\n                        });\n                    }\n\n                    if (mergedConfig.onError) {\n                        mergedConfig.onError(error);\n                        resolve(null);\n                    } else {\n                        reject(error);\n                    }\n                }\n\n                commitMutation(resolvedEnvironment, {\n                    ...mergedConfig,\n                    mutation,\n                    variables: mergedConfig.variables,\n                    onCompleted: (response, errors) => {\n                        if (errors) {\n                            // FIXME: This isn't right. onError expects a single error.\n                            handleError(errors);\n                            return;\n                        }\n\n                        if (isMounted()) {\n                            setState({\n                                loading: false,\n                                data: response,\n                                error: null,\n                            });\n                        }\n\n                        if (mergedConfig.onCompleted) {\n                            mergedConfig.onCompleted(response);\n                        }\n                        resolve(response);\n                    },\n                    onError: handleError,\n                });\n            });\n        },\n        [\n            resolvedEnvironment,\n            configs,\n            mutation,\n            variables,\n            uploadables,\n            onCompleted,\n            onError,\n            optimisticUpdater,\n            optimisticResponse,\n            updater,\n            isMounted,\n        ],\n    );\n\n    return [mutate, state];\n}\n","import * as React from 'react';\nimport { Environment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nexport const RelayEnvironmentProvider = function<\n    TEnvironment extends Environment = Environment\n>(props: { children: React.ReactNode; environment: TEnvironment }): JSX.Element {\n    const context = React.useMemo(() => ({ environment: props.environment }), [props.environment]);\n    return (\n        <ReactRelayContext.Provider value={context}>{props.children}</ReactRelayContext.Provider>\n    );\n};\n","import { GraphQLTaggedNode } from 'relay-runtime';\nimport {\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n    FRAGMENT_NAME,\n} from './RelayHooksTypes';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): $Call<KeyReturnType<TKey>>;\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): $Call<KeyReturnType<TKey>> | null;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, false, FRAGMENT_NAME);\n    return data;\n}\n\nexport function useSuspenseFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): $Call<KeyReturnType<TKey>>;\nexport function useSuspenseFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): $Call<KeyReturnType<TKey>> | null;\nexport function useSuspenseFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\nexport function useSuspenseFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, true, FRAGMENT_NAME);\n    return data;\n}\n\nexport function useFragmentSubscription<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: $Call<KeyReturnType<TKey>>) => void,\n): void;\nexport function useFragmentSubscription<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: $Call<KeyReturnType<TKey>> | null) => void,\n): void;\nexport function useFragmentSubscription<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>) => void,\n): void;\nexport function useFragmentSubscription<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>) => void,\n): void {\n    useOssFragment(fragmentNode, fragmentRef, false, FRAGMENT_NAME, callback);\n}\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    KeyType,\n    KeyTypeData,\n    PAGINATION_NAME,\n    ReturnTypePagination,\n    ReturnTypePaginationSuspense,\n} from './RelayHooksTypes';\nimport { useOssFragment } from './useOssFragment';\n\nexport function usePagination<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePagination<TQuery, TKey, KeyTypeData<TKey>>;\nexport function usePagination<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePagination<TQuery, TKey | null, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, false, PAGINATION_NAME);\n    return data;\n}\n\nexport function usePaginationFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePaginationSuspense<TQuery, TKey, KeyTypeData<TKey>>;\nexport function usePaginationFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypePaginationSuspense<TQuery, TKey | null, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef, true, PAGINATION_NAME);\n    return data;\n}\n\nexport function usePaginationSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: ReturnTypePagination<TQuery, TKey, KeyTypeData<TKey>>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid;\nexport function usePaginationSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: ReturnTypePagination<TQuery, TKey | null, KeyTypeData<TKey> | null>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid {\n    useOssFragment(fragmentNode, fragmentRef, false, PAGINATION_NAME, callback);\n}\n","import { useEffect } from 'react';\nimport { OperationType } from 'relay-runtime';\nimport { RenderProps, LoadQuery } from './RelayHooksTypes';\nimport { useForceUpdate } from './useForceUpdate';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport const usePreloadedQuery = <TOperationType extends OperationType = OperationType>(\n    loadQuery: LoadQuery,\n): RenderProps<TOperationType> => {\n    const forceUpdate = useForceUpdate();\n    const environment = useRelayEnvironment();\n\n    useEffect(() => {\n        return loadQuery.subscribe(forceUpdate);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [loadQuery]);\n\n    return loadQuery.getValue(environment) as RenderProps<TOperationType>;\n};\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    KeyType,\n    KeyTypeData,\n    REFETCHABLE_NAME,\n    ReturnTypeRefetchNode,\n    ReturnTypeRefetchSuspenseNode,\n} from './RelayHooksTypes';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useRefetchable<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey>>;\nexport function useRefetchable<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentInput, fragmentRef, false, REFETCHABLE_NAME);\n    return data;\n}\n\nexport function useRefetchableFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchSuspenseNode<TQuery, TKey, KeyTypeData<TKey>>;\nexport function useRefetchableFragment<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): // tslint:disable-next-line no-unnecessary-generics\nReturnTypeRefetchSuspenseNode<TQuery, TKey, KeyTypeData<TKey> | null> {\n    const [data] = useOssFragment(fragmentInput, fragmentRef, true, REFETCHABLE_NAME);\n    return data;\n}\n\nexport function useRefetchableSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n    callback: (data: ReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey>>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid;\nexport function useRefetchableSubscription<TQuery extends OperationType, TKey extends KeyType>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n    callback: (data: ReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey> | null>) => void,\n): // tslint:disable-next-line no-unnecessary-generics\nvoid {\n    useOssFragment(fragmentInput, fragmentRef, false, REFETCHABLE_NAME, callback);\n}\n","import { useEffect } from 'react';\nimport { GraphQLSubscriptionConfig, requestSubscription, OperationType } from 'relay-runtime';\nimport {\n    SkipGraphQLSubscriptionConfig,\n    SkipSubscriptionConfig,\n    SubscriptionConfig,\n} from './RelayHooksTypes';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\n    opts?: SubscriptionConfig,\n): void;\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: SkipGraphQLSubscriptionConfig<TSubscriptionPayload>,\n    opts: SkipSubscriptionConfig,\n): void;\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\n    opts?: SubscriptionConfig,\n): void {\n    const environment = useRelayEnvironment();\n    const skip = opts && opts.skip;\n\n    useEffect(() => {\n        if (skip) {\n            return;\n        }\n        const { dispose } = requestSubscription(environment, config);\n        return dispose;\n    }, [environment, config, skip]);\n}\n"],"names":["ReactRelayContext","createRelayContext","React","forceCache","force","createOperation","gqlQuery","variables","cacheConfig","createOperationDescriptor","getRequest","fetchQuery","fetchResolver","_a","releaseQueryTimeout","query","promise","env","setLoading","_b","doRetain","disposeTemporary","_refetchSubscription","disposable","isLoading","error","updateLoading","loading","dispose","clearTemporaryRetain","disposeRequest","clearTimeout","unsubscribe","fetch","environment","operation","fetchPolicy","onComplete","onNext","renderPolicy","_e","request","identifier","retain","policy","queryStatus","check","status","hasFullQuery","snapshot","lookup","fragment","full","isNetwork","onlyStore","refetchSubscription_1","resolveNetworkPromise_1","cleanup_1","subscribe","complete","e","next","store","poll","start","subscription","Promise","resolve","getData","checkAndSuspense","suspense","useLazy","toThrow","setTimeout","cache","Map","getOrCreateQueryFetcher","networkCacheConfig","queryFetcher","has","get","QueryFetcher","setQuery","emptyforceUpdate","cacheConfigOverride","options","_this","node","resolveResult","forceUpdate","result","retry","this","data","fetcher","delete","disposeSnapshot","rootSubscription","skip","fetchHasReturned","_o","areEqual","getQuery","fetchKey","setForceUpdate","set","useForceUpdate","useRelayEnvironment","useInternalQuery","ref","useRef","current","useEffect","emptyFunction","internalLoadQuery","Error","reject","callback","getForceUpdate","getValue","resolveEnvironment","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","getValueAtPath","path","path_1","_i","key","Array","isArray","invariant","getStateFromConnection","direction","fragmentNode","connection","cursor","hasMore","_c","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","END_CURSOR","START_CURSOR","edges","pageInfo","getRefetchMetadata","componentDisplayName","metadata","plural","refetchMetadata","refetch","refetchableRequest","default","fragmentRefPathInResponse","fragmentPathInResult","identifierField","getPaginationMetadata","paginationRequest","paginationMetadata","connectionPathInFragmentData","connectionMetadata","stream","getPromiseForActiveRequest","getFragmentResult","missData","isMissingData","map","some","name","unmounted","parentVariables","fragmentVariables","fragmentData","identifierValue","_selector","kind","selectors","owner","refetchVariables","id","pagination","fetcherNext","fetcherPrevious","fetcherRefecth","_environment","fragmentRef","isEquals","isEqualsFragmentRef","_fragmentRefRefetch","_fragmentRef","_idfragmentrefetch","getFragmentIdentifier","_fragment","resolverData","refreshHooks","UNSTABLE_renderPolicy","count","loadMore","isRequestActive","extraVariables","UNSTABLE_extraVariables","baseVariables","paginationVariables","backwardMetadata","forwardMetadata","paginationVariables_1","getPaginationVariables","undefined","refetchable","_loading","FragmentResolver","subscribeResolve","_subscribeResolve","prevFragment","prevIDs","getDataIDsFromFragment","nextIDs","getFragmentVariables","fRef","getVariablesFromFragment","idfragment","_idfragment","getSelector","selector","fragmentOwner","networkPromise","pendingOperationName","params","getOperationTracker","getPendingOperationsAffectingOwner","pendingOperations","op","join","fragmentName","displayName","_getAndSavePromiseForFragmentRequestInFlight","parentQueryName","then","catch","_error","hasNext","hasPrevious","isLoadingNext","errorNext","isLoadingPrevious","errorPrevious","loadNext","loadPrevious","_disposable","renderedSnapshot","dataSubscriptions","forEach","idx","push","latestSnapshot","useOssFragment","resolver","setUnmounted","useMemo","getFragment","useCallback","useState","props","context","Provider","value","children","mutation","userConfig","state","setState","isMounted","useMounted","relayEnvironment","resolvedEnvironment","configs","uploadables","onCompleted","onError","optimisticUpdater","optimisticResponse","updater","config","mergedConfig","handleError","commitMutation","response","errors","loadQuery","fragmentInput","opts"],"mappings":"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"}